(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{711:function(_,v,t){"use strict";t.r(v);var r=t(12),o=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-回流和重绘的概念与触发条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-回流和重绘的概念与触发条件"}},[_._v("#")]),_._v(" 1. 回流和重绘的概念与触发条件")]),_._v(" "),t("h3",{attrs:{id:"_1-回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-回流"}},[_._v("#")]),_._v(" 1） 回流")]),_._v(" "),t("p",[_._v("​\t当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为"),t("strong",[_._v("回流")]),_._v("。")]),_._v(" "),t("p",[_._v("下面这些操作会导致回流：")]),_._v(" "),t("ul",[t("li",[_._v("页面的"),t("strong",[_._v("首次渲染")])]),_._v(" "),t("li",[_._v("浏览器的"),t("strong",[_._v("窗口大小")]),_._v("发生变化")]),_._v(" "),t("li",[_._v("元素的"),t("strong",[_._v("内容")]),_._v("发生变化")]),_._v(" "),t("li",[_._v("元素的"),t("strong",[_._v("尺寸或者位置")]),_._v("发生变化")]),_._v(" "),t("li",[_._v("元素的"),t("strong",[_._v("字体")]),_._v("大小发生变化")]),_._v(" "),t("li",[_._v("激活"),t("strong",[_._v("CSS伪类")])]),_._v(" "),t("li",[t("strong",[_._v("查询某些属性")]),_._v("或者调用某些方法")]),_._v(" "),t("li",[_._v("添加或者删除可见的"),t("strong",[_._v("DOM")]),_._v("元素")])]),_._v(" "),t("p",[_._v("在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：")]),_._v(" "),t("ul",[t("li",[_._v("全局范围：从根节点开始，对整个渲染树进行重新布局")]),_._v(" "),t("li",[_._v("局部范围：对渲染树的某部分或者一个渲染对象进行重新布局")])]),_._v(" "),t("h3",{attrs:{id:"_2-重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-重绘"}},[_._v("#")]),_._v(" 2） 重绘")]),_._v(" "),t("p",[_._v("当页面中某些元素的"),t("strong",[_._v("样式发生变化")]),_._v("，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是"),t("strong",[_._v("重绘")]),_._v("。")]),_._v(" "),t("p",[_._v("下面这些操作会导致回流：")]),_._v(" "),t("ul",[t("li",[_._v("color、background 相关属性：background-color、background-image 等")]),_._v(" "),t("li",[_._v("outline 相关属性：outline-color、outline-width 、text-decoration")]),_._v(" "),t("li",[_._v("border-radius、visibility、box-shadow")])]),_._v(" "),t("p",[_._v("注意： "),t("strong",[_._v("当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。")])]),_._v(" "),t("h2",{attrs:{id:"_2-如何避免回流与重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何避免回流与重绘"}},[_._v("#")]),_._v(" 2. 如何避免回流与重绘")]),_._v(" "),t("p",[t("strong",[_._v("减少回流与重绘的措施：")])]),_._v(" "),t("ul",[t("li",[_._v("操作DOM时，尽量在低层级的DOM节点进行操作")]),_._v(" "),t("li",[_._v("不要使用"),t("code",[_._v("table")]),_._v("布局， 一个小的改动可能会使整个"),t("code",[_._v("table")]),_._v("进行重新布局")]),_._v(" "),t("li",[_._v("使用CSS的表达式")]),_._v(" "),t("li",[_._v("不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。")]),_._v(" "),t("li",[t("strong",[_._v("使用absolute或者fixed")]),_._v("，使元素脱离文档流，这样他们发生变化就不会影响其他元素")]),_._v(" "),t("li",[t("strong",[_._v("避免频繁操作DOM")]),_._v("，可以创建一个文档片段"),t("code",[_._v("documentFragment")]),_._v("，在它上面应用所有DOM操作，最后再把它添加到文档中")]),_._v(" "),t("li",[_._v("将元素先"),t("strong",[_._v("设置"),t("code",[_._v("display: none")])]),_._v("，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),_._v(" "),t("li",[_._v("将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于"),t("strong",[_._v("浏览器的渲染队列机制")]),_._v("。")])]),_._v(" "),t("p",[_._v("浏览器针对页面的回流与重绘，进行了自身的优化——"),t("strong",[_._v("渲染队列")])]),_._v(" "),t("p",[_._v("​\t"),t("strong",[_._v("浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。")])]),_._v(" "),t("p",[_._v("​\t上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。")]),_._v(" "),t("h2",{attrs:{id:"_3-如何优化动画"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何优化动画"}},[_._v("#")]),_._v(" 3. 如何优化动画")]),_._v(" "),t("p",[_._v("​\t对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就会导致页面的性能问题，我们可以将动画的"),t("code",[_._v("position")]),_._v("属性设置为"),t("code",[_._v("absolute")]),_._v("或者"),t("code",[_._v("fixed")]),_._v("，将动画脱离文档流，这样他的回流就不会影响到页面了。")]),_._v(" "),t("h2",{attrs:{id:"_4-documentfragment是什么-用它跟直接操作dom的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-documentfragment是什么-用它跟直接操作dom的区别是什么"}},[_._v("#")]),_._v(" 4. documentFragment是什么？用它跟直接操作DOM的区别是什么？")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("定义")]),_._v("： DocumentFragment，是一个没有父对象的最小文档对象，并且DocumentFragment不是真实DOM树的一部分，所以变化不会触发DOM树的重新渲染。")])]),_._v(" "),t("p",[_._v("​\t当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将"),t("strong",[_._v("DocumentFragment")]),_._v(" 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。")])])}),[],!1,null,null,null);v.default=o.exports}}]);