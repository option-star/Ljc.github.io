(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{735:function(t,_,v){"use strict";v.r(_);var s=v(12),r=Object(s.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"_1-浏览器渲染过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器渲染过程"}},[t._v("#")]),t._v(" 1. 浏览器渲染过程")]),t._v(" "),v("h3",{attrs:{id:"_1-构建dom树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-构建dom树"}},[t._v("#")]),t._v(" 1. 构建DOM树")]),t._v(" "),v("p",[t._v("​\t由于浏览器无法直接理解和使用html，所以需要将HTML转换为浏览器能够理解的结构——DOM树。")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("转换")]),t._v("： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。")]),t._v(" "),v("li",[v("strong",[t._v("令牌化")]),t._v("： 浏览器将字符串转换成 "),v("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fparsing.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("W3C HTML5 标准"),v("OutboundLink")],1),t._v("规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。")]),t._v(" "),v("li",[v("strong",[t._v("词法分析")]),t._v("： 发出的令牌转换成定义其属性和规则的“对象”。")]),t._v(" "),v("li",[v("strong",[t._v("DOM构建")]),t._v("： 由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系")])]),t._v(" "),v("p",[t._v("​\t已经生成DOM树了，但是DOM节点的样式依然不知道，要让DOM节点拥有正确的样式，这样就需要样式计算了。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204092237282.webp",alt:"img"}})]),t._v(" "),v("h3",{attrs:{id:"_2-样式计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-样式计算"}},[t._v("#")]),t._v(" 2.  样式计算")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"}),v("p",[t._v("​\t样式 计算的目的是为了计算出DOM节点中每个元素的具体样式。具体分为以下三步。")])]),v("h4",{attrs:{id:"_1-把css转换为浏览器能够理解的结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-把css转换为浏览器能够理解的结构"}},[t._v("#")]),t._v(" 1）把CSS转换为浏览器能够理解的结构")]),t._v(" "),v("p",[t._v("CSS样式的主要来源：")]),t._v(" "),v("ul",[v("li",[t._v("通过"),v("code",[t._v("link")]),t._v("引用的外部 CSS 文件")]),t._v(" "),v("li",[v("code",[t._v("<style>")]),t._v("标签内的样式")]),t._v(" "),v("li",[t._v("元素的 "),v("code",[t._v("style")]),t._v(" 属性内嵌的 CSS")])]),t._v(" "),v("p",[t._v("​\t浏览器无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会将CSS文本转换为浏览器可以理解的结构"),v("code",[t._v("styleSheets")]),t._v(", 该结构同时具备了查询和 修改功能。")]),t._v(" "),v("h4",{attrs:{id:"_2-转换样式表的属性值-使其标准化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-转换样式表的属性值-使其标准化"}},[t._v("#")]),t._v(" 2）转换样式表的属性值，使其标准化")]),t._v(" "),v("p",[t._v("​\tCSS文本中有很多属性值，如"),v("code",[t._v("em")]),t._v("、"),v("code",[t._v("blue")]),t._v("、"),v("code",[t._v("bold")]),t._v("，这些类型数值不容易被渲染引擎理解，所以需要将所有值转化为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057791.png",alt:"img"}})]),t._v(" "),v("h4",{attrs:{id:"_3-计算出dom树中每个节点的具体样式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-计算出dom树中每个节点的具体样式"}},[t._v("#")]),t._v(" 3）计算出DOM树中每个节点的具体样式")]),t._v(" "),v("p",[t._v("现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("继承")]),t._v("： 每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫"),v("code",[t._v("UserAgent样式")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("层叠")]),t._v("： 定义了如何合并来自多个源的属性值的算法。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057576.png",alt:"img"}})]),t._v(" "),v("p",[t._v("​\t这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。")]),t._v(" "),v("h3",{attrs:{id:"_3-布局定位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-布局定位"}},[t._v("#")]),t._v(" 3. 布局定位")]),t._v(" "),v("p",[t._v("​\t计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。")]),t._v(" "),v("p",[t._v("Chrome在布局阶段需要完成两个任务：创建布局树和布局计算")]),t._v(" "),v("h4",{attrs:{id:"_1-创建布局树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建布局树"}},[t._v("#")]),t._v(" 1） 创建布局树")]),t._v(" "),v("p",[t._v("​\t你可能注意到了DOM树还含有很多不可见的元素，比如head标签，还有使用了"),v("code",[t._v("display:none")]),t._v("属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。")]),t._v(" "),v("ol",[v("li",[t._v("遍历DOM树中的所有可见节点，并把这些节点加入到布局中；")]),t._v(" "),v("li",[t._v("而不可间的节点会被布局树忽略掉")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057867.png",alt:"img"}})]),t._v(" "),v("h4",{attrs:{id:"_2-布局计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-布局计算"}},[t._v("#")]),t._v(" 2）布局计算")]),t._v(" "),v("p",[t._v("​\t计算每个元素的几何坐标位置，并将这些信息保存在布局树中。")]),t._v(" "),v("h3",{attrs:{id:"_4-图层分层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-图层分层"}},[t._v("#")]),t._v(" 4. 图层分层")]),t._v(" "),v("p",[t._v("​\t现在我们有了布局树，但依旧不能直接开始绘制。")]),t._v(" "),v("p",[t._v("​\t因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果。渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。")]),t._v(" "),v("p",[t._v("​\t浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。")]),t._v(" "),v("p",[t._v("​\t并不是布局树的每个节点都能生成一个图层，如果一个节点没有自己的层，那么这个节点就从属于父节点的图层")]),t._v(" "),v("p",[t._v("​\t通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。")]),t._v(" "),v("ol",[v("li",[v("p",[v("strong",[t._v("拥有层叠上下文属性的元素会被提升为单独的一层")])]),t._v(" "),v("ul",[v("li",[t._v("HTML根元素本身就具有层叠上下文")]),t._v(" "),v("li",[t._v("普通元素设置"),v("strong",[t._v("position不为static")]),t._v("并且"),v("strong",[t._v("设置了z-index属性")]),t._v("，会产生层叠上下文。")]),t._v(" "),v("li",[t._v("元素的 "),v("strong",[t._v("opacity")]),t._v(" 值不是 1")]),t._v(" "),v("li",[t._v("元素的 "),v("strong",[t._v("transform")]),t._v(" 值不是 none")]),t._v(" "),v("li",[t._v("元素的 "),v("strong",[t._v("filter")]),t._v(" 值不是 none")]),t._v(" "),v("li",[t._v("元素的 "),v("strong",[t._v("isolation")]),t._v(" 值是isolate")]),t._v(" "),v("li",[v("strong",[t._v("will-change")]),t._v("指定的属性值为上面任意一个。")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("需要剪裁（clip）的地方也会被创建为图层")]),v("code",[t._v("overflow")])])])]),t._v(" "),v("h3",{attrs:{id:"_5-图层绘制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-图层绘制"}},[t._v("#")]),t._v(" 5. 图层绘制")]),t._v(" "),v("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("首先会把图层拆解成一个一个的绘制指令，排布成一个绘制列表")])]),t._v(" "),v("li",[v("p",[t._v("当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程")])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057540.webp",alt:"img"}})]),t._v(" "),v("h3",{attrs:{id:"_6-分块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-分块"}},[t._v("#")]),t._v(" 6. 分块")]),t._v(" "),v("p",[t._v("​\t可能图层很大，页面内容很多，展示的只是视口内容，所以这种情况下，绘制全部图层内容的话，会产生较大开销。所以合成线程接下来会把图层划分为图块（tile）。")]),t._v(" "),v("h3",{attrs:{id:"_7-光栅化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-光栅化"}},[t._v("#")]),t._v(" 7. 光栅化")]),t._v(" "),v("p",[t._v("接着上面的步骤，有了图块之后，"),v("strong",[t._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。")])]),t._v(" "),v("ul",[v("li",[t._v("图块是栅格化执行的最小单位")]),t._v(" "),v("li",[t._v("渲染进程中专门维护了一个"),v("strong",[t._v("栅格化线程池")]),t._v("，专门负责把"),v("strong",[t._v("图块")]),t._v("转换为"),v("strong",[t._v("位图数据")])]),t._v(" "),v("li",[t._v("合成线程会选择视口附近的"),v("strong",[t._v("图块(tile)")]),t._v("，把它交给"),v("strong",[t._v("栅格化线程池")]),t._v("生成位图")]),t._v(" "),v("li",[t._v("生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给"),v("code",[t._v("合成线程")])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057676.webp",alt:"img"}})]),t._v(" "),v("h3",{attrs:{id:"_8-合成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-合成"}},[t._v("#")]),t._v(" 8.合成")]),t._v(" "),v("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),t._v(" "),v("p",[t._v("浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，然后把这部分内存发送给显卡。")]),t._v(" "),v("p",[t._v("屏幕每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传过来的页面后，会合成相应的图像，并将图像保存到"),v("strong",[t._v("后缓冲区")]),t._v("， 然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057437.webp",alt:"img"}})]),t._v(" "),v("h2",{attrs:{id:"_2-更新了元素的几何属性-重排"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-更新了元素的几何属性-重排"}},[t._v("#")]),t._v(" 2. 更新了元素的几何属性（重排）")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057961.png",alt:"img"}})]),t._v(" "),v("p",[t._v("​\t从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的")]),t._v(" "),v("h2",{attrs:{id:"_3-更新元素的绘制属性-重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-更新元素的绘制属性-重绘"}},[t._v("#")]),t._v(" 3. 更新元素的绘制属性（重绘）")]),t._v(" "),v("p",[t._v("接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057889.png",alt:"img"}})]),t._v(" "),v("p",[t._v("​\t从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。"),v("strong",[t._v("相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_4-直接合成阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-直接合成阶段"}},[t._v("#")]),t._v(" 4. 直接合成阶段")]),t._v(" "),v("p",[t._v("​\t那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。")]),t._v(" "),v("p",[t._v("具体流程参考下图：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/option-star/imgs/202204141057581.png",alt:"img"}})]),t._v(" "),v("p",[t._v("​\t举个例子：比如使用CSS的transform来实现动画效果，"),v("strong",[t._v("避免了回流跟重绘")]),t._v("，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以"),v("strong",[t._v("相对于重绘和重排，合成能大大提升绘制效率。")])]),t._v(" "),v("h2",{attrs:{id:"_5-如何减少回流-重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何减少回流-重绘"}},[t._v("#")]),t._v(" 5. 如何减少回流，重绘")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("动画使用"),v("strong",[t._v("transform")]),t._v("或者"),v("strong",[t._v("opacity")]),t._v("实现")])]),t._v(" "),v("li",[v("p",[t._v("使用 "),v("strong",[t._v("visibility 替换 display: none")]),t._v(" ，因为前者只会引起重绘，后者会引发回流（改变了布局）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("不要使用 table 布局")]),t._v("，可能很小的一个小改动会造成整个 table 的重新布局")])]),t._v(" "),v("li",[v("p",[t._v("动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用**"),v("code",[t._v("requestAnimationFrame")]),t._v("**")])]),t._v(" "),v("li",[v("p",[t._v("使用"),v("code",[t._v("createDocumentFragment")]),t._v("进行批量的 DOM 操作")])]),t._v(" "),v("li",[v("p",[t._v("对于 resize、scroll 等进行防抖/节流处理。")])])]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ol",[v("li",[v("a",{attrs:{href:"https://juejin.cn/post/6847902222349500430",target:"_blank",rel:"noopener noreferrer"}},[t._v("「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W字）"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://www.rrfed.com/2017/02/26/chrome-layout/",target:"_blank",rel:"noopener noreferrer"}},[t._v("从Chrome源码看浏览器如何layout布局"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=r.exports}}]);