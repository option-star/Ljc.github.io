(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{692:function(_,v,e){"use strict";e.r(v);var t=e(12),o=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("blockquote",[e("p",[_._v("数据到渲染的整个过程")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/ljcdzh/my_pic/raw/master/img/202203252015361.png",alt:"img"}})]),_._v(" "),e("h2",{attrs:{id:"_1-数据驱动是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据驱动是什么"}},[_._v("#")]),_._v(" 1. 数据驱动是什么？")]),_._v(" "),e("p",[_._v("​\t数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。\t当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。")]),_._v(" "),e("h2",{attrs:{id:"_2-new-vue发生了什么-this-init"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-new-vue发生了什么-this-init"}},[_._v("#")]),_._v(" 2. new Vue发生了什么？("),e("code",[_._v("this._init")]),_._v(")")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[_._v("​\tVue中通过"),e("code",[_._v("this._init")]),_._v("方法进行初始化")])]),e("blockquote",[e("p",[_._v("this.init发生了什么？")])]),_._v(" "),e("ol",[e("li",[_._v("合并配置")]),_._v(" "),e("li",[_._v("初始化生命周期")]),_._v(" "),e("li",[_._v("初始化事件中心")]),_._v(" "),e("li",[_._v("初始化渲染")]),_._v(" "),e("li",[_._v("初始化data、props、computed、watcher")]),_._v(" "),e("li",[_._v("最后，如果有"),e("code",[_._v("el")]),_._v("属性，则通过"),e("code",[_._v("vm.$mount")]),_._v("方法挂载"),e("code",[_._v("vm")]),_._v(", 挂载的目标就是把模板渲染成最终的DOM")])]),_._v(" "),e("h2",{attrs:{id:"_3-vue中如何挂载-mount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中如何挂载-mount"}},[_._v("#")]),_._v(" 3. Vue中如何挂载？"),e("code",[_._v("$mount")])]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[_._v("​\tvue在通过"),e("code",[_._v("this._init")]),_._v("方法进行初始化操作，然后通过"),e("code",[_._v("$mount")]),_._v("方法，进行挂载。")])]),e("blockquote",[e("p",[e("code",[_._v("$mount")]),_._v("发生了什么？")])]),_._v(" "),e("ol",[e("li",[_._v("先限制vue不能挂载在body、html的根节点中; Typora中自动补全标签。因为挂载点是会被组件模板自身替换，显然body、hmlt不能被替换。")]),_._v(" "),e("li",[_._v("如果没有定义render方法，则会把"),e("code",[_._v("el")]),_._v("或者"),e("code",[_._v("template")]),_._v("字符串通过"),e("code",[_._v("compileToFunctions")]),_._v("方法转换成"),e("code",[_._v("render")]),_._v("方法")]),_._v(" "),e("li",[_._v("最后调用原型上的"),e("code",[_._v("$mount")]),_._v("方法中的"),e("code",[_._v("mountComponent")]),_._v("方法进行挂载。")])]),_._v(" "),e("h2",{attrs:{id:"_4-为什么vue中在多处定义-mount方法呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么vue中在多处定义-mount方法呢"}},[_._v("#")]),_._v(" 4. 为什么vue中在多处定义"),e("code",[_._v("$mount")]),_._v("方法呢？")]),_._v(" "),e("p",[_._v("​\t之所以这样涉及完全是为了复用，因为"),e("code",[_._v("$mount")]),_._v("是可以被"),e("code",[_._v("runtime only")]),_._v("版本的Vue直接使用的。")]),_._v(" "),e("h2",{attrs:{id:"_5-vue中如何通过render函数进行渲染的呢-mountcomponent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue中如何通过render函数进行渲染的呢-mountcomponent"}},[_._v("#")]),_._v(" 5. vue中如何通过render函数进行渲染的呢？"),e("code",[_._v("mountComponent")])]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[_._v("​\tvue通过调用"),e("code",[_._v("$mount")]),_._v("方法获取到"),e("code",[_._v("render")]),_._v("函数后，会调用原型的"),e("code",[_._v("$mount")]),_._v("方法，其方法通过"),e("code",[_._v("mountComponent")]),_._v("方法进行实例的挂载")])]),e("blockquote",[e("p",[e("code",[_._v("mountComponent")]),_._v("发生了什么？")])]),_._v(" "),e("ol",[e("li",[_._v("先实例化一个渲染"),e("code",[_._v("Watcher")]),_._v("， 在它的回调函数中调用"),e("code",[_._v("updateComponent")]),_._v("方法")]),_._v(" "),e("li",[_._v("在"),e("code",[_._v("updateComponent")]),_._v("中，调用"),e("code",[_._v("vm._render")]),_._v("方法先生成虚拟node， 最后调用"),e("code",[_._v("vm._update")]),_._v("更新DOM")]),_._v(" "),e("li",[_._v("最后判断为根节点的时候设置"),e("code",[_._v("vm._isMounted")]),_._v("为"),e("code",[_._v("true")]),_._v("，标识这个实例已经挂载了，同时执行"),e("code",[_._v("mounted")]),_._v("的钩子。")])]),_._v(" "),e("blockquote",[e("p",[e("code",[_._v("渲染Watcher")]),_._v("在"),e("code",[_._v("mountComponent")]),_._v("中有什么用？")])]),_._v(" "),e("ol",[e("li",[_._v("初始化的时候会执行回调函数")]),_._v(" "),e("li",[_._v("当vm实例中的检测的数据发生变化的时候执行回调函数")])]),_._v(" "),e("h2",{attrs:{id:"_6-如何把render函数渲染成一个虚拟node-vm-render"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-如何把render函数渲染成一个虚拟node-vm-render"}},[_._v("#")]),_._v(" 6. 如何把render函数渲染成一个虚拟Node？"),e("code",[_._v("vm._render")])]),_._v(" "),e("blockquote",[e("p",[e("code",[_._v("vm._render")]),_._v("函数发生了什么？")])]),_._v(" "),e("ul",[e("li",[e("code",[_._v("vm._render")]),_._v("最终通过执行"),e("code",[_._v("createElement")]),_._v("方法并返回"),e("code",[_._v("Vnode")]),_._v(", 它是一个虚拟Node")])]),_._v(" "),e("h2",{attrs:{id:"_7-如何把虚拟node渲染成真实dom-vm-update"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何把虚拟node渲染成真实dom-vm-update"}},[_._v("#")]),_._v(" 7. 如何把虚拟Node渲染成真实DOM? "),e("code",[_._v("vm._update")])]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[_._v("​\t通过"),e("code",[_._v("compileToFunction")]),_._v("获取到render函数后，然后通过"),e("code",[_._v("vm._render")]),_._v("方法将render方法转换成虚拟Node，然后通过"),e("code",[_._v("vm._update")]),_._v("方法将虚拟Node渲染成真实DOM")])]),e("blockquote",[e("p",[e("code",[_._v("vm._update")]),_._v("发生了什么？")])]),_._v(" "),e("ol",[e("li",[e("p",[_._v("核心就是调用"),e("code",[_._v("vm.__patch__")]),_._v("方法， 而在浏览器端渲染实际就是调用"),e("code",[_._v("createPatchFuntion")]),_._v("方法的返回值")])]),_._v(" "),e("li",[e("p",[_._v("而调用"),e("code",[_._v("createPatchFuntion")]),_._v("方法时，会传入一个对象，包含"),e("code",[_._v("nodeOps")]),_._v("参数和"),e("code",[_._v("modules")]),_._v("参数。")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("nodeOps")]),_._v(" : 封装了一系列DOM操作的方法")]),_._v(" "),e("li",[e("code",[_._v("modules")]),_._v("：定义了一些模块的钩子函数的实现，在patch的过程中会被调用。")])])]),_._v(" "),e("li",[e("p",[_._v("而"),e("code",[_._v("createPatchFunction")]),_._v("方法 最后返回了一个"),e("code",[_._v("patch")]),_._v("方法，也就是调用的"),e("code",[_._v("vm.__patch__")]),_._v("方法")])])]),_._v(" "),e("blockquote",[e("p",[_._v("而"),e("code",[_._v("patch")]),_._v("函数又发生了什么呢？")])]),_._v(" "),e("ol",[e("li",[_._v("首次渲染会调用"),e("code",[_._v("createElm")])]),_._v(" "),e("li",[_._v("实际上整个过程就是递归创建了一个完整的DOM树并插入到Body上")]),_._v(" "),e("li",[_._v("最后，更具之前递归"),e("code",[_._v("createElm")]),_._v("生成的"),e("code",[_._v("Vnode")]),_._v("插入顺序队列，执行相关"),e("code",[_._v("insert")]),_._v("钩子函数。")])]),_._v(" "),e("h2",{attrs:{id:"_8-为什么把patch的相关代码分散到各个目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-为什么把patch的相关代码分散到各个目录"}},[_._v("#")]),_._v(" 8. 为什么把patch的相关代码分散到各个目录？")]),_._v(" "),e("p",[_._v("​\t"),e("code",[_._v("patch")]),_._v(" 是平台相关的，在 Web 和 Weex 环境，它们把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 "),e("code",[_._v("nodeOps")]),_._v(" 和 "),e("code",[_._v("modules")]),_._v("，它们的代码需要托管在 "),e("code",[_._v("src/platforms")]),_._v(" 这个大目录下。")]),_._v(" "),e("p",[_._v("​\t而不同平台的 "),e("code",[_._v("patch")]),_._v(" 的主要逻辑部分是相同的，所以这部分公共的部分托管在 "),e("code",[_._v("core")]),_._v(" 这个大目录下。差异化部分只需要通过参数来区别，这里用到了一个函数柯里化的技巧，通过 "),e("code",[_._v("createPatchFunction")]),_._v(" 把差异化参数提前固化，这样不用每次调用 "),e("code",[_._v("patch")]),_._v(" 的时候都传递 "),e("code",[_._v("nodeOps")]),_._v(" 和 "),e("code",[_._v("modules")]),_._v(" 了")])])}),[],!1,null,null,null);v.default=o.exports}}]);