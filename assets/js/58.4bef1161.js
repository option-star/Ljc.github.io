(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{710:function(t,_,a){"use strict";a.r(_);var v=a(12),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-什么是服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是服务端渲染"}},[t._v("#")]),t._v(" 1. 什么是服务端渲染？")]),t._v(" "),a("p",[t._v("​\t什么是服务端渲染？服务端渲染就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过JavaScript脚本的执行，即可直接构建出希望的DOM树并展示到页面中。这个服务端组件HTML的过程，叫服务端渲染。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/ljcdzh/my_pic/raw/master/img/202203311833029.webp",alt:"1"}})]),t._v(" "),a("h2",{attrs:{id:"_2-服务端渲染的发展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务端渲染的发展"}},[t._v("#")]),t._v(" 2. 服务端渲染的发展")]),t._v(" "),a("h3",{attrs:{id:"_1-服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务端渲染"}},[t._v("#")]),t._v(" 1）服务端渲染")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/ljcdzh/my_pic/raw/master/img/202203311946660.webp",alt:"2"}})]),t._v(" "),a("p",[t._v("​\t浏览器器发送请求url， 服务端接收到请求后，向数据库查询数据后，床底给对应的模块，并渲染html片段，服务器拿到对应的片段后组装成一个完整的html，返回给浏览器。")]),t._v(" "),a("p",[a("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("每次只更新一小部分数据，服务器都需要重新查询数据库，构建html，返回给浏览器")]),t._v(" "),a("li",[t._v("前端的js脚本文件和后端的代码混杂，不好维护。")])]),t._v(" "),a("h3",{attrs:{id:"_2-客户端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-客户端渲染"}},[t._v("#")]),t._v(" 2）客户端渲染")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/ljcdzh/my_pic/raw/master/img/202203311946856.webp",alt:"3"}})]),t._v(" "),a("p",[a("strong",[t._v("流程")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("浏览器请求URL")]),t._v(" "),a("li",[t._v("前端服务器直接返回一个空的静态hmtl文件")]),t._v(" "),a("li",[t._v("这个html文件中加载了很多渲染页面需要的js脚本文件和CSS样式表")]),t._v(" "),a("li",[t._v("浏览器拿到HTML文件后开始加载脚本和样式表的，并执行脚本")]),t._v(" "),a("li",[t._v("这个时候脚本请求后端服务提供的API，获取数据完成后将数据通过js脚本动态地将数据渲染到页面中，完成页面显示。")])]),t._v(" "),a("h3",{attrs:{id:"_3-服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务端渲染"}},[t._v("#")]),t._v(" 3）服务端渲染")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/ljcdzh/my_pic/raw/master/img/202203311946192.webp",alt:"4"}})]),t._v(" "),a("p",[a("strong",[t._v("流程")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("浏览器请求URL")]),t._v(" "),a("li",[t._v("前端服务器接收到URL请求之后，根据不同的URL，前端服务器向后端服务器请求数据，请求完成后，前端服务器会组装一个携带了具体数据的HTML文本，并且返回给浏览器")]),t._v(" "),a("li",[t._v("浏览器得到HTML之后开始渲染页面，同时，浏览器加载并执行 JavaScript 脚本，给页面上的元素绑定事件，让页面变得可交互，当用户与浏览器页面进行交互，如跳转到下一个页面时，浏览器会执行 JavaScript 脚本，向后端服务器请求数据，获取完数据之后再次执行 JavaScript 代码动态渲染页面。")])]),t._v(" "),a("h2",{attrs:{id:"_3-服务端渲染的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务端渲染的优缺点"}},[t._v("#")]),t._v(" 3. 服务端渲染的优缺点")]),t._v(" "),a("h3",{attrs:{id:"_1-利于seo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-利于seo"}},[t._v("#")]),t._v(" 1）利于SEO")]),t._v(" "),a("p",[t._v("​\t有利于SEO，就是有利于爬虫爬取自己的页面，当别人通过搜索引擎搜索相关内容时，网页就会排行比较前，流量就比较多。")]),t._v(" "),a("p",[t._v("​\t为什么使用服务端渲染会有利于爬虫爬取呢 ？其实爬虫也分高级爬虫和低级爬虫：")]),t._v(" "),a("ul",[a("li",[t._v("高级爬虫：请求url，会加载执行js脚本渲染页面，爬取渲染后的结果")]),t._v(" "),a("li",[t._v("低级爬虫：请求url。返回的html是什么内容就爬取什么内容。")])]),t._v(" "),a("p",[t._v("所以，低级爬虫对于服务端渲染就比较无力，因为服务端渲染返回的是一个空的HTML。所以使用服务端渲染比较有利于低级爬虫。")]),t._v(" "),a("h3",{attrs:{id:"_2-白屏时间更短"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-白屏时间更短"}},[t._v("#")]),t._v(" 2） 白屏时间更短")]),t._v(" "),a("p",[a("strong",[t._v("服务端渲染")]),t._v("： 浏览器发送请求的时候，就返回了一个带有数据的HTML文件，不需要加载执行javascript，直接解析HTML文件，构建DOM树就可以了。")]),t._v(" "),a("p",[a("strong",[t._v("客户端渲染")]),t._v("：浏览器输入url后，会得到空的html文件，这就产生了白屏，需要进行加载并执行javascript，然后进行渲染才得到最后渲染的页面。越是复杂的项目，需要加载的js文件就越多，白屏时间就越长。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/ljcdzh/my_pic/raw/master/img/202203311910304.webp",alt:"5"}})]),t._v(" "),a("h3",{attrs:{id:"_3-缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-缺点"}},[t._v("#")]),t._v(" 3）缺点")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("代码复杂度增加")]),t._v("：代码需要兼容客户端和服务端两种运行情况，而且有些外部扩展库需要特殊处理才能在服务端运行。")]),t._v(" "),a("li",[a("strong",[t._v("需要更多服务器负载均衡")]),t._v("：由于服务器增加了渲染HTML的需求，使得node.js服务新增了获取数据获取的IO和渲染HTML的CPU占用，可通过设置缓存策略，和相应的服务器负载。")]),t._v(" "),a("li",[a("strong",[t._v("同构资源处理")]),t._v("：劣势在于程序需要具有通用性。结合 Vue 的钩子来说，能在 SSR 中调用的生命周期只有 "),a("strong",[t._v("beforeCreate")]),t._v(" 和 "),a("strong",[t._v("created")]),t._v("，这就导致在使用三方 API 时必须保证运行不报错。在三方库的引用时需要特殊处理使其支持服务端和客户端都可运行")])])])}),[],!1,null,null,null);_.default=r.exports}}]);