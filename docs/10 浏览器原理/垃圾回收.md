---
title: 垃圾回收
date: 2021-11-07
sidebar: 'auto'
tags:
- 垃圾回收
categories:
- 浏览器
isShowComments: true
---

## GC是什么

GC（Garbage Collection）， 程序工作过程中会产生很多垃圾，这些垃圾是程序中不用的内存空间或者是之前用过的，以后不会再用的内存空间

## 为什么需要GC

在Chrome中，V8被限制内存的使用，为什么要限制？

- 表层原因： V8最初为浏览器而设计，不太可能遇到大量内存的使用场景
- 深层原因： V8的垃圾回收机制限制（如果清楚大量内存垃圾会消耗时间，从而降低性能）

## 垃圾回收策略

### 标记清除法

::: tip

**标记清除法**：引擎在执行GC时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，这些出发点称之为一组根对象，而根对象在浏览器中有全局的window对象、文档D0M树等

:::

#### 过程

1. 垃圾收集器在运行时，会给内存中的变量全部标记成0
2. 然后从根对象开始遍历，遍历到的对象标记为1
3. 清除所有标记为0的垃圾，销毁并回收它们所占用的内存空间
4. 最后，把所有对象的标记修改为0，等待下一轮的垃圾回收

#### 优点

- 实现简单，只需用一位二进制标记状态（0/1）

#### 缺点

1. **内存碎片化**。清除后剩余对象内存位置不变会导致空闲空间不连续，出现内存碎片化。
2. **分配速度慢**。即时使用First-fit策略，操作时间复杂度依旧为O(n)

#### 内存分配

![image-20211107091459458](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070914644.png)

清除后剩余对象位置不变而导致空闲内存不连续，也就出现“内存碎片”，这就涉及了“内存分配问题”。

![image-20211107091631820](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070916935.png)

假设新建对象分配内存需要大小为size,由于空闲内存不连续，则需要对空闲内存列表进行一次单向遍历找出大于等于size的块才能为其分配。有一下三种分配方式。

1. **First-fit**, 找到大于等于size的块立即返回
2. **Best-fit**,  返回大于等于size的最小分块
3. **Worst-fit**, 找到最大分块，然后切成两部分，一部分size大小，并将该部分返回。

这三种策略里面Worst-fit的空间利用率看起来最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于First-fit和Best-fit来说，考虑到分配的速度和效率First-fit是更为明智的选择。

#### 优化

::: tip

**标记清除法** ： 标记阶段与标记清除法一致，只是标记结束后，标记整理算法会将不需清理的对象向内存的一端移动，最后清理标记的内存。

:::

![image-20211107092141007](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070921181.png)



### 引用计数法

![截屏2021-08-12 下午10.23.45.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070939688.webp)

#### 过程

1. 值每增加一个变量指向，则该值引用次数加1
2. 值每减少一个变量指向，则该值引用次数减1
3. 值的引用次数为0时，清除所占用的内存

#### 举例

```js
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```

#### 循环引用

```js
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
```

如上图所示，A引用着B，B引用着A，此时A、B的计数都是2，但当test（）执行完之后，A、B理应被清除，但是由于计数不为0，所以不会被清除，若该函数被大量调用，就会造成大量的内存不会被释放。

对于标记清除法，test执行完之后，A、B当作非活动对象被清除，而对于引用计数算法而言不被回收，所以建议使用标记清除法。

#### 优点

- 产生垃圾后立即回收
- 不需要遍历所有对象

#### 缺点

- 循环引用问题
- 计数器增加额外的内存空间



## V8对GC的优化

### 分代回收

#### 新生代/老生代

V8将堆内存分为新生代和老生代两个区域：

- **新生代**：存放一些新、小、存活时间短的对象
- **老生代**：存放一些老、大、存活时间长的对象

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071020527.webp)

V8分别使用了不同的垃圾回收器和不同的回收算法，对新老生代区域进行垃圾回收。

- **新生代**：副垃圾回收器 + Scavenge算法
- **老生代**：主垃圾回收器 + Mark-Sweep（标记清除） && Mark-Compact（标记整理）算法

#### 新生代垃圾回收

![image.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071050843.webp)

![image.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071049876.webp)

在新生代中，主要使用`Scavenge`算法进行垃圾回收。`Scavange`算法将新生代堆空间分为两部分：`from-sapce`和`to-space`.

过程如下：

1. 新加入的对象都会存放在`from-space`, 当`from-space`快被写满时，就需要进行一次垃圾清理操作。
2. 新生代垃圾回收器会对`from-space`中的活动对象进行标记
3. 标记完成后，新生代垃圾回收器将`from-space`的活动对象复制进`to-space`并进行排序
4. 新生代垃圾回收器会将非活动对象占用的空间清除掉
5. 最后，将`from space`与`to-space`进行互换。

注意：

1. 如果一个对象经过复制后，依旧存活，会被移到老生代区
2. 如果复制一个对象到`to-space`后，`to-space`占用超过了25%,那么这个对象会被直接移动到老生代区中，设置25%的原因是,当完成`Scavenge`回收后，`from space`与`to-space`进行互换，继续进行对象内存的分配，若占比过大，将影响后续内存的分配。

#### 老生代垃圾回收

![image.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071113649.webp)

因为老生代的对象通常比较大，若如新生代般操作的话，就会比较耗时，从而导致效率不高，所以老生代垃圾回收器则采用标记清除法。

1. 首先是标记阶段，从一组根元素开始，遍历这组根元素，遍历过程中能达到的元素称为活动对象，没有达到的元素被称为非活动对象
2. 清除阶段。老生代回收器会直接将非活动对象，也就是数据清除掉
3. 由于标记清除算法在清楚后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，所以V8就采用了标记整理算法

::: tip

**全停顿（Stop-The-World）：**由于Javascript是单线程的，在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后在恢复脚本执行，我们把这种行为叫做全停顿

:::

### 增量标记

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071321089.webp)

增量标记主要在标记阶段进行优化。增量就是将一次 `GC` 标记的过程，分成了很多小步，每执行完一小步就让JS代码执行一会，这样交替多次后完成一轮 `GC` 标记。

#### 三色标记法（暂停与恢复）

##### 为什么需要三色标记法？

如果采用标记清除法时，通过0、1记录状态，那在垃圾回收器执行一段增量回收后，暂停后使用主线程去执行JS代码，当垃圾回收器再次被启动时，内存中全是0、1标志位，无法得知下一步到哪。所以为了解决这个问题，才出现了`三色标记法`。

##### 过程

::: tip

- **白**：未被标记的对象
- **灰**：自身被标记，子引用对象未被登记
- **黑**：自身与子引用对象皆被标记

:::

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071356596.webp)

1. 在GC并发开始时，所有对象都是白色的
2. 将所有的GC Roots直接引用的对象标记为灰色集合
3. 判断灰色对象集合中对象是否存在子引用
   1. 不存在： 则将灰色对象放入黑色集合
   2. 存在：将其所有子引用对象存放到灰色集合，当前对象放入黑色集合中
4. 通过循环判断灰色集合，直至灰色集合中所有的对象变黑后，本轮标记完成，并把白色集合中的对象标记为不可达对象
5. 标记结束后，白色对象为GC Roots不可达，可以进行垃圾回收



##### 如何进行恢复

可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成。

- 无灰色节点：直接进入清理阶段
- 有灰色节点：恢复时直接从灰色节点开始继续执行标记。



#### 写屏障（增量中修改引用）

`写屏障 (Write-barrier)` 机制一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 `GC` 标记阶段可以正确标记，这个机制也被称作 `强三色不变性`。

### 懒性清理

**懒性清除**主要对清除阶段进行优化，如果当前的剩余内存空间足以让JS代码运行，则延迟清除过程，先让JS运行，也无需一次性清理完所有的非活动对象内存。

### 并行回收

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071316553.webp)

并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。

### 并发回收

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071319880.webp)

**并发回收**：主线程在执行 `JavaScript` 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起。

## V8当前回收机制

### 副垃圾回收器

![image.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071410256.webp)

在V8新生代垃圾回收中，使用了并行的机制。将活动对象从`form-space`复制到`to-space`时，启用多个辅助线程，并行进行整理。

由于多个线程竞争一个新生代堆资源，可能多个线程复制了同一个对象，所以V8中，当线程复制完对象后，需要去维护复制对象的指针转发地址，以便其他线程判断活动对象是否被复制过。

### 主垃圾回收器

![image.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111071410604.webp)

在老生代垃圾回收中

1. 标记阶段： 主要使用并发标记，主线程在开始执行JS时，辅助线程也同时执行标记操作（标记操作全部由辅助线程完成）
2. 清除阶段： 主要使用并行清理操作，主线程在执行清理操作时，多个辅助线程也同时执行清理操作

注： 清理的任务会采用增量的方式分批在各个JS任务之间执行。

## 参考

1. [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-0)
1. [赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！](https://juejin.cn/post/6995706341041897486#heading-5)
1. [JVM 三色标记法与读写屏障](https://juejin.cn/post/6996123086296252453#heading-1)

