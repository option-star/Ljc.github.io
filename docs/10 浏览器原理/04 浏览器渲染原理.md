---
title: 浏览器04 渲染原理
date: 2022-03-23
sidebar: 'auto'
categories:
- 10浏览器
isShowComments: true
---

## 1. 浏览器渲染过程

### 1. 构建DOM树

​	由于浏览器无法直接理解和使用html，所以需要将HTML转换为浏览器能够理解的结构——DOM树。

​	已经生成DOM树了，但是DOM节点的样式依然不知道，要让DOM节点拥有正确的样式，这样就需要样式计算了。





### 2. 样式计算

:::tip

​	样式 计算的目的是为了计算出DOM节点中每个元素的具体样式。具体分为以下三步。

:::

#### 1）把CSS转换为浏览器能够理解的结构

CSS样式的主要来源：

- 通过` link `引用的外部 CSS 文件
- `<style>`标签内的样式
- 元素的 `style` 属性内嵌的 CSS

​	浏览器无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构`styleSheets`, 该结构同时具备了查询和 修改功能。





#### 2）装换样式表的属性值，使其标准化

​	CSS文本中有很多属性值，如`em`、`blue`、`bold`，这些类型数值不容易被渲染引擎理解，所以需要将所有值转化为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203291802601.png)

#### 3）计算出DOM树中每个节点的具体样式

现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？

##### 继承规则

首先是CSS继承。CSS继承就是每个DOM节点都包含有父节点的样式。

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203291808992.png)

##### 层叠规则

​	**层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法**。



##### 总结

​	样式计算阶段的目的是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。



### 3. 布局定位

​	现在，我们有DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。

Chrome在布局阶段需要完成两个任务：创建布局树和布局计算

#### 1） 创建布局树

​	你可能注意到了DOM树还含有很多不可见的元素，比如head标签，还有使用了`display:none`属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

1. 遍历DOM树中的所有可见节点，并把这些节点加入到布局中；
2. 而不可间的节点会被布局树忽略掉

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203291813916.png)

#### 2）布局计算

​	计算每个元素的几何坐标位置，并将这些信息保存在布局树中。



### 4. 图层分层

​	现在我们有了布局树，但依旧不能直接开始绘制。

​	因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果。渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

​	浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

​	并不是布局树的每个节点都能生成一个图层，如果一个节点没有自己的层，那么这个节点就从属于父节点的图层

​	通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

​	1、**拥有层叠上下文属性的元素会被提升为单独的一层**：明确定位属性`position`的元素、定义透明属性`opacity`的元素、使用 CSS 滤镜`filter`的元素等，都拥有层叠上下文属性。

​	2、**需要剪裁（clip）的地方也会被创建为图层**`overflow`



### 5. 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

1. 首先会把图层拆解成一个一个的绘制指令，排布成一个绘制列表

2. 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程

   

### 6. 分块

合成线程接下来会把图层划分为图块（tile）



### 7. 光栅化

​	在光栅化线程池中将按照视口附近的图块转换为位图

### 8.合成

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。



### 9. 流程总结

1. 渲染进程将HTML内容转换为能够读懂的DOM树结构
2. 渲染引擎将CSS样式表转换为浏览器理解的styleSheets，计算出DOM节点的样式
3. 创建布局树，并计算元素的布局信息
4. 对布局树进行分层，并生成分层树
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分为图块，并在光栅化线程池中将图块转换为位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器进程根据DrawQuad消息生成也买你，并显示到显示器上。



## 2. 更新了元素的几何属性（重排）

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203291841836.png)

​	从上图可以看出，如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的



## 3. 更新元素的绘制属性（重绘）

接下来，我们再来看看重绘，比如通过JavaScript更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203291840361.png)

​	从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。



## 4. 直接合成阶段

​	那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

具体流程参考下图：

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203291839518.png)

​	在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。





## 5. 如何减少回流，重绘

-  动画使用**transform**或者**opacity**实现
- 使用 **visibility 替换 display: none** ，因为前者只会引起重绘，后者会引发回流（改变了布局）

- **不要使用 table 布局**，可能很小的一个小改动会造成整个 table 的重新布局

- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用**` requestAnimationFrame`**

-  使用`createDocumentFragment`进行批量的 DOM 操作

- 对于 resize、scroll 等进行防抖/节流处理。

## 6. GPU加速原因

