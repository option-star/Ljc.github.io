---
title: React01 组件基础
date: 2022-04-22
sidebar: 'auto'
categories:
- 13React
isShowComments: true
---



## 1 . React事件机制

![77fa6b2a59c92e160bc171f9c80783e7.jpg](https://cdn.jsdelivr.net/gh/option-star/imgs/202204221320200.webp)

​		`JSX`上写的事件并没有绑定在对应的事件DOM上，而是通过事件代理的方式，将所有的事件都统一绑定在了`document`上。这样的方式不仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。

​	另外冒泡到`document`上的事件也不是原生浏览器事件，而是React自己实现的合成事件(`SyntheticEvent`)。所以阻止事件冒泡应该用`event.preventDefault`而不是`event.stopPropagation`。



## 2. 实现合成事件的目的？

- 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力
- 对于原生浏览器事件来说，浏览器会给监听器创建一个事件的对象。如果有很多事件监听，那就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理他们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。



## 3. React的事件和普通的HTML事件有什么不同？

> 区别：

- 对于事件名称命名方式，原生事件为全小写，react事件采用小驼峰
- 对于事件函数处理语法，原生事件全为字符串，react事件为函数
- react事件不能采用`return false`的方式来阻止浏览器的默认行为，而必须要明确地调用`preventDefault()`来阻止默认行为
- 事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到`document`上，所以尽量避免原生事件和 合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到`document`上合成事件才会执行。

## 4. 合成事件的优点

​	合成事件是react模拟原生DOM事件所有能力的一个事件对象。

- 兼容所有浏览器，更好地跨平台
- 将事件统一存放在一个数组，避免频繁地新增和删除（垃圾回收）
- 方便react统一管理和事务机制。

## 5. React组件中怎么做事件代理？它的原理是什么？

​	React基于Virtual DOM实现了一个`SyntheticEent`层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。

在React底层，主要对合成事件做了两件事：

- **事件委派**： React会把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。
- **自动绑定**： React组件中，每个方法的上下文都会执行该组件的实例，即自动绑定this为当前组件。



## 6. React高阶组件、Render props、hooks有什么区别，为什么不断迭代？

:::tip

​	HOC、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。

:::

### 1）HOC

> 是什么？

​	HOC是一种组件的设计模式，HOC接受一个组件和额外的参数，返回一个新的组件。HOC是纯函数，没有副作用。

> 使用

```js
// hoc的定义
function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        data: selectData(DataSource, props)
      };
    }
    // 一些通用的逻辑处理
    render() {
      // ... 并使用新数据渲染被包装的组件!
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };

// 使用
const BlogPostWithSubscription = withSubscription(BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id));

```



> 优点

​	逻辑复用、不影响被包裹组件的内部逻辑

> 缺点

​	hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖。

### 2）Render props

> 概念

​	具有render prop的组件接受一个返回react元素的函数，将render的渲染逻辑注入到组件内部。

> 使用

```js
// DataProvider组件内部的渲染逻辑如下
class DataProvider extends React.Components {
     state = {
    name: 'Tom'
  }

    render() {
    return (
        <div>
          <p>共享数据组件自己内部的渲染逻辑</p>
          { this.props.render(this.state) }
      </div>
    );
  }
}

// 调用方式
<DataProvider render={data => (
  <h1>Hello {data.name}</h1>
)}/>
```

> 优点

​	数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。

> 缺点

​	无法在return语句外访问数据、嵌套写法不够优雅。



### 3）Hooks

> 使用

```js
// 自定义一个获取订阅数据的hook
function useSubscription() {
  const data = DataSource.getComments();
  return [data];
}
// 
function CommentList(props) {
  const {data} = props;
  const [subData] = useSubscription();
    ...
}
// 使用
<CommentList data='hello' />
```

> 优点

- 解决hoc的prop重名问题
- 解决render props因共享数据，而出现嵌套地狱的问题
- 能在return之外使用数据的问题

**注意**： hook只能在组件顶层使用，不可在分支语句中使用



## 7. 对React-Fiber的理解，它解决了什么问题？

​	React V15在渲染时，会递归比对VirtualDOM树，找出需要变变动的节点，然后同步更新。这个过程期间，React会占据浏览器资源，这会导致用户触发的事件得不到响应，并且导致掉帧，导致用户感到卡顿。

​	Fiber也称协程，一种控制流程让出的机制。让出CPU的执行权，让CPU能在这段时间执行其他操作。渲染的过程可以被中断，可以将控制权交给浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。



## 8. React.Component和React.PureComponent的区别

​	PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。

​	在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。

​	不过，pureComponent中的 shouldComponentUpdate() 进行的是**浅比较**，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。

​	使用pureComponent的**好处**：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。



## 9. Component、Element、Instance之间有什么联系和区别？

- **元素：** 一个元素`element`是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件`component`，你想让它在屏幕上呈现成什么样子。元素`element`可以在它的属性`props`中包含其他元素(译注:用于形成元素树)。创建一个React元素`element`成本很低。元素`element`创建之后是不可变的。
- **组件：** 一个组件`component`可以通过多种方式声明。可以是带有一个`render()`方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性`props`作为输入，把返回的一棵元素树作为输出。
- **实例：** 一个实例`instance`是你在所写的组件类`component class`中使用关键字`this`所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。

函数式组件(`Functional component`)根本没有实例`instance`。类组件(`Class component`)有实例`instance`，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。



## 10. React.createClass和extends Component的区别有哪些？

### 1）语法区别

​	createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。

​	createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。

### 2）propType和getDefaultProps

- React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.
- React.Component：通过设置两个属性propTypes和defaultProps

### 3）状态区别

- React.createClass：通过getInitialState()方法返回一个包含初始值的对象
- React.Component：通过constructor设置初始状态

### 4）this区别

- React.createClass：会正确绑定this
- React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。

### 5）Mixins

- React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。

- 如果使用 ES6 的方式来创建组件，那么 `React mixins` 的特性将不能被使用了。





