---
title: HTTPS
date: 2021-11-08
sidebar: 'auto'
tags:
- HTTPS
- 计算机网络
categories:
- 计算机网络
isShowComments: true
---


## 为什么需要HTTPS

::: tip

HTTP存在的问题

:::

### 1. 通信使用明文可能被窃听

#### 原因

	由于HTTP本身不具备加密功能，所以也没办法做到对通信进行加密所以只能使用明文方式发送。

#### 加密对象

-   **通信加密**：HTTP通过和SSL(安全套接层)或TLS(安全传输层协议)的组合使用，加密HTTP的通信内容。用SSL建立安全通信线路后，就可以在这条线路上进行HTTP通信了。

![image-20211108162247812](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081622868.png)

-   **内容加密**：由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。

    ![image-20211108162230764](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081622827.png)

### 2. 不验证通信方的身份就可能遭遇伪装

#### 原因

​		在HTTP协议通信时，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患：

1.   不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。
2.   无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
3.   无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限
4.   无法判定请求是来自何方、出自谁手。
5.    即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击).

#### 解决

​		HTTP协议无法确定通信方但是SSL可以。SSL不仅提供加密处理，还提供一种被称为证书的东西，可用于确定方。证书是由CA机构颁发，用于证明服务器和客户端是真实存在的。伪造证书从技术角度来说是非常困难的，所以只要能够确认通信方所持有的证书即可判断通信方的真实意图。

### 3. 无法证明报文的完整性，可能已遭篡改

​		由于HTTP无法保证报文的真实性，因此，请求发送后直到对方接收之前的这段时间里，请求被修改了也无法获悉。遭攻击者拦截并篡改内容的攻击称为中间人攻击。

## 什么是HTTPS

![https](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081457057.jpeg)

HTTPS并不是一种新协议，只是HTTP通信接口部分使用SSL(`Secure Socket Layer`)或者TLS（`Transport LayerSecurity`）协议替代。

通常, HTTP直接和TCP通信。当使用SSL时，则HTTP先和SSL通信，再由SSL和TCP通信。简而言之，HTTPS就是身披SSL协议外壳的HTTP。

使用SSL后 ,HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

SSL是独立于HTTP的协议，所以在应用层的SMTP和Telnet等协议均可配合SSL协议使用

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081512824.webp)

## HTTPS做了什么

- `加密(Encryption)`， 通过对数据加密，防止数据被监听
- `数据一致性(Data integrity)`，确保数据在传输过程中不会被修改。
- `身份认证(Authentication)`，指确认对方的真实身份，防止中间人攻击并建立用户信任。

## HTTPS的加密方式

### 1. 共享密钥加密

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081632618.jpeg)

​		加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。以共享密钥方式加密时必须将密钥也发给对方,可究竟怎样才能安全地转交？

### 2. 公开密钥加密

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081634880.jpeg)

​		公开密钥加密的方式很好的解决了安全问题。公开密钥加密使用一对非对称的密钥。一把为私钥，一把为公钥，其中私钥是不能让任何人得知的，而公钥则可以随便公布。发送密文的一段，使用对方的公钥进行加密，对方接收到加密信息后，使用自己的私钥进行解密。这样就避免了发送解密的私钥，解决了对称密钥共享的安全问题。(公钥加密对称加密的密钥，私钥则进行解密)。

### 3. 混合密钥加密（HTTPS）

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081635407.jpeg)

​		HTTPS采用共享密钥加密和公开密钥加密的混合加密机制。在交换密钥环节，使用公开密钥加密技术，之后通信报文交换的阶段，则可以使用共享密钥加密技术。



## SSL/TLS

::: tip

[RFC文档](https://datatracker.ietf.org/doc/html/rfc5246)

:::

![TLS/SSL协议](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081716418.webp)

### SSL和TLS的关系

-   1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
-   1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
-   1996年，SSL 3.0版问世，得到大规模应用。
-   1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版[TLS](https://en.wikipedia.org/wiki/Secure_Sockets_Layer) 1.0版。
-   2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的[修订版](https://tools.ietf.org/html/rfc6176)。

### 基本运行过程

​		SSL/TLS协议的基本思路是采用[公钥加密法](https://en.wikipedia.org/wiki/Public-key_cryptography)，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

但是，这里有两个问题：

1.   如果保证公钥不被篡改？

解决方法：将公钥放在[数字证书](https://en.wikipedia.org/wiki/Digital_certificate)中。只要证书是可信的，公钥就是可信的。

2.   公钥加密计算量太大，如何减少耗用的时间？

解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

所以，SSL/TLS协议基本过程是这样的：

1.   客户端向服务器端索要并验证公钥。
2.   双方协商生成"对话密钥"。
3.   双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

### 握手阶段详细过程

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081653280.png)

#### 1. 客户端发出请求（ClientHello）

​		首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。

请求内容：

-   支持的协议版本，比如TLS 1.0版。
-   一个客户端生成的随机数，稍后用于生成"对话密钥"。
-   支持的加密方法，比如RSA公钥加密。
-   支持的压缩方法。

#### 2.  服务器回应（SeverHello）

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。

响应内容：

-   确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
-   一个服务器生成的随机数，稍后用于生成"对话密钥"。
-    确认使用的加密方法，比如RSA公钥加密。
-   服务器证书。

#### 3. 客户端回应

​		客户端收到服务器回应后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

​		如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送响应。

响应内容：

-    一个随机数。该随机数（"pre-master key"）用服务器公钥加密，防止被窃听。
-   编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
-   客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

:::tip

整个握手阶段，客户端和服务器同时就有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，[dog250](http://blog.csdn.net/dog250/article/details/5717162)有解释：

解释：

​		"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

​		对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

​		pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

:::

#### 4. 服务器的最后回应

​		服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后向客户端响应。

响应信息：

-   编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
-   服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。



## HTTPS的通信步骤

::: tip

有必要了解一下的故事：[用信鸽来解释 HTTPS](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485207&idx=1&sn=64827cd627ad08798d21076cef1b7cfa&chksm=ebd6383bdca1b12de54dc4e157543b2ff63fc8c876a73f830d3855760b90ae109b239ade633f&mpshare=1&scene=24&srcid=0416kj0u5u9OKS1MIT61ETQM#rd)

:::

![HTTPS加解密流程](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081526798.webp)



![过程](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081503309.jpeg)

1.  客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2.  服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送Certificate报文。报文中包含公开密钥的证书（用于非对称加密）。
4.  最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。
5. SSL第一次握手结束之后，客户端以Client KeyExchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串（用于对称加密）。该报文已用步骤3中的公开密钥进行加密。
6.  接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。
7. 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送Change Cipher Spec报文。
9.  服务器同样发送Finished报文。
10.  服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。
11.  应用层协议通信，即发送HTTP响应
12. 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。



## HTTPS的缺点

​		与纯文本通信相比，加密通信**会消耗更多的CPU和内存资源**。如果每次通信都加密，会消耗相当多的资源。平摊到一台计算机上，能够处理的请求数量必定随之减少。因此，如果是非敏感信息则使用HTTP通信，只有包含个人信息等敏感数据时，才利用https加密通信。特别是每当那些访问量较多的web网站进行加密处理，它们所承担的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要隐藏的信息才会加密，以节约资源。 

## 参考

1. [图解HTTP](https://weread.qq.com/web/reader/3da32b505dd9f43da9a1acakd8232f00235d82c8d161fb2)
2. [看完这篇 HTTPS，和面试官扯皮就没问题了](https://juejin.cn/post/6844904089495535624)
3. [《大前端进阶 安全》系列 HTTPS详解（通俗易懂）](https://juejin.cn/post/6844904127420432391)
4. [分分钟让你理解HTTPS](https://juejin.cn/post/6844903599303032845)
4. [SSL/TLS协议运行机制的概述](SSL/TLS协议运行机制的概述)

