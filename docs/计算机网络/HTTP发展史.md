---
title: HTTP发展史
date: 2021-11-09
sidebar: 'auto'
tags:
- HTTP
categories:
- 计算机网络
isShowComments: true
---



## 0 开端

-   20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，这被认为是互联网的起源。
-   70 年代，研究人员基于对 ARPA 网的实践和思考，发明出了著名的 TCP/IP 协议。该协议具有良好的分层结构和稳定的性能
-    80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了网络。
-   1989 年，蒂姆伯纳斯-李博士发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。在篇文章中他确立了三项关键技术：URI、HTML、HTTP。基于这三项技术，可以把超文本系统完美地运行在互联网上，李博士把这个系统称为“万维网”（World Wide Web）。

<img src="https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081734252.webp" alt="图片描述" style="zoom:150%;" />

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091854601.jpeg)

## 1. HTTP0.9

### 1.1 简介

​		1991 年 HTTP（HyperText Transfer Protocol，超文本传输协议）正式诞生，当时的版本是 0.9。其主**要用于学术交流，在网络之间传输体积很小的HTML文件。协议定义了客户端发起请求、服务端响应请求的通信模式**

### 1.2 请求流程

![http/0.9请求流程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/3/16e305dd85a7c849~tplv-t2oaga2asx-watermark.awebp)

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091552023.png)

1.   首先客户端根据IP地址、端口和服务器建立TCP连接，而建立连接的过程就是TCP协议三次握手的过程。
2.   建立好连接后，客户端会发送一个GET请求行的信息， 如`GET /index.html` 用来获取index.html
3.   服务器接受请求信息后，读取对应的HTML文件，并将连接以ASCII字符流返回给客户端
4.   HTML文档传输完成后，断开连接



### 1.3 特点

-   **只有一个请求行，没有HTTP请求头和请求体**
-   **服务器也没有返回头信息**
-   **返回的内容是以ASCII字符流来传输的**（因为都是HTML格式文件，且ASCII编码范围为0 ~127,  一个字符即可表示，用ASCII来传输节省空间）



### 1.4 传输层协议

​		TCP



### 1.5 瓶颈

-   **只支持HTML文件**： 传输文件类型只支持HTML文件
-   **局限于ASCII编码** ：文件格式仅局限于ASCII编码



## 2. HTTP1.0

### 2.1 介绍

​		为 了满足传输多种类型文件的需求， **HTTP/1.0核心改变就是引入头部设定**，头部内容以键值对的形式设置，在HTTP发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。

![http/1.0请求流程](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111082239155.webp)

![preview](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091551522.jpeg)

### 2.2 请求体/响应体

**请求头**：

```js
accept: text/html // 期待服务器返回html类型的文件
accept-encoding: gzip, deflate, br // 期待服务器可以采用gzip、deflate、br其中一种压缩方式
accept-Charset: ISO-8859-1,utf-8 // 期待返回的文件编码是 ISO-8859-1或utf-8
accept-language: zh-CN,zh // 期望⻚面的优先语言是中文
```

**响应头**：

```js
content-encoding: br // 表示服务器采用了br的压缩方式
content-type: text/html; charset=UTF-8 // 服务器返回的是html文件，并且该文件的编码类型是UTF-8
```

### 2.3 特点

:::tip

​		头部字段不仅用于解决不同类型文件传输的问题，也可以实现其他很多功能。

:::

-   为了支持多种类型文件，浏览器需要知道返回的数据类型
-   为了减轻传输性能，支持压缩后传输
-   为了提供国际化的支持，浏览器需要指明需要的语言版本
-   为了准确读取文件，浏览器需要知道文件的编码类型
-   为了告诉浏览器服务器最终处理该请求的情况，引入状态码
-   为了减轻服务器的压力，提供Cache机制，用来缓存已经下载过的数据
-   为了方便服务器统计客户端的基本信息，在请求头中加入用户代理User Agent字段



### 2.4 传输层协议

​		TCP

### 2.5 瓶颈

-   **短链接**： 每一次进行HTTP通信，都需要建立TCP链接、传输HTTP数据和断开TCP连接三个阶段，会增加大量无畏的开销
-   **队头阻塞** ： 只有前面请求的返回之后才能进行下一次请求，如果某个请求没有及时返回，会引起队头阻塞
-   **每个服务器只支持一个域名**： 每个域名绑定一个唯一的IP地址，因此一个服务器只能支持一个域名
-   **无法接收动态生成的内容**：需要在响应头中设置完整的数据大小（`Content-Length`），浏览器根据设置的数据大小来接受数据，这种方式对于接受动态生成的内容无能为力
-   **不支持断点续存**： 存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续存



## 3 HTTP1.1

### 3.1 特点

#### 3.1.1 长链接（核心）

**HTTP1.0**: 每进行一次通信，都需要经历建立连接、传输数据和断开数据三个阶段。当一个页面引入了较多外部文件时，这个建立连接和断开连接的过程就会增加大量网络开销。

**HTTP/1.1**: 引入TCP连接复用，即一个TCP默认不关闭，可以被多个HTTP请求复用

即HTTP1.1中的`Connection： keep-alive`

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091600807.jpeg)



#### 3.1.2 管道网络传输

**HTTP1.0**: 队头阻塞

**HTTP1.1**: 引入管道机制，一个TCP连接，可以同时发送多个请求。（响应的顺序必须和请求的顺序一致，因此不常用，FirFox和Chrome已经放弃）



#### 3.1.3 并发连接

​	通过使用CDN实现域名分片机制，对于一个域名的请求允许分配多个长连接，减轻了整个资源的下载时间



#### 3.1.4 对动态生成的内容提供完美支持

​		HTTP/1.1通过引入Chunktransfer(分块传输编码)机制来解决该问题,服务器会将数据分割成若干个任意大小的数据块,毎个数据块发送时会附上数据块的长度,最后使用一个零长度的块作为发送数据完成的标志,这样就提供了对动态内容的支持



#### 3.1.5 引入客户端Cookie、安全机制



#### 3.1.6 带宽优化

**HTTP1.0**：例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能

**HTTP1.1**：在请求头引入了range头域,它允许只请求资源的某个部分,即返回码是206( Partial Content)

#### 3.1.7 缓存处理

HTTP1.0：主要使用`header`里的`If-Modified-Since`,`Expires`来做为缓存判断的标准

HTTP1.1：引入了更多的缓存控制策略例如`Entity tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match`等更多可供选择的缓存头来控制缓存策略。

#### 3.1.8 错误通知的管理

​		新增了24个错误状态响应码

- 409(Conflict)表示请求的资源与资源的当前状态发生冲突;
- 410(Gone)表示服务器上的某个资源被永久性的删除。

#### 3.1.9 添加host头

**HTTP1.0**: 每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（`hostname`）。

**HTTP1.1**: 随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（`Multi-homed Web Servers`），并且它们共享一个IP地址。在请求头中增加了Host字段,用来表示当前的域名地址,从而使服务器就可以根据不同的Host值做不同的处理





### 3.2 传输层协议

​		TCP

### 3.3 瓶颈

#### 3.3.1 TCP的慢启动

​		TCP慢启动带来性能问题的原因是因为一些关键资源文件不大，但是慢启动会慢慢加快放数据的速度，所以小文件花费的时间也比较长

#### 3.3.2 无请求优先级控制

​		同时开启多条TCP连接，这些TCP连接之间不会协商资源的优先级，竞争固定的带宽，可能会影响关键资源的下载。

#### 3.3.3 对头阻塞问题

#### 		一条TCP连接中同一时刻只能处理一个请求。在当前的请求还没结束之前，其他的请求只能处于阻塞状态，这种情况被称为 **队头阻塞**

#### 3.3.4 头部未压缩

​	请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；







## 4 HTTP2.0

### 4.1 介绍

​		HTTP/2.0的目的是通过支持请求和响应的多路复用来减少延迟，通过压缩HTTP首部字段将协议开销降低，同时增加请求优先级和服务器推送的支持。

### 4.2 核心

 		HTTP/2 默认不再使用 ASCII 编码传输，而是改为二进制数据，来提升传输效率。

​		客户端在发送请求时会将每个请求的内容封装成不同的带有编号的二进制帧（Frame），然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分与组合的过程。

​		有了二进制分帧后，对于同一个域，客户端只需要与服务端建立一个连接即可完成通信需求，这种利用一个连接来发送多个请求的方式称为「多路复用」。每一条路都被称为一个 stream（流）, 为了防止两端流ID冲突,客户端发起的流具有奇数ID,服务端发起的流具有偶数ID

​		通过多路复用，能充分利用带宽，最大限度避免了TCP的慢启动所带来的问题，同时实现首部压缩、服务器推送等功能，使得页面资源的传输速度得到大幅提升。

![preview](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091830718.jpeg)

### 4.3 特点

#### 4.3.1 多路复用机制

​		通过利用一个TCP连接，即可并行发送多个请求和响应。

::: tip

​		多路复用与长连接区别：

![图片描述](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091847134.webp) 

:::

#### 4.3.2 可以设置请求的优先级

​		在发送请求时，标上请求的优先级，服务器在接受到请求后会优先处理优先级高的请求。0: 表示最高优先级，2的31次方-1表示最低优先级

#### 4.3.3 允许服务端主动向客户端推送数据

##### 介绍

​		服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。当客户端想获取其他资源可重缓存中获取。

##### 过程

-   `PUSH_PROMISE`帧是服务端向客户端有意推送资源的信号。
-   如果客户端不需要服务端`Push`，可在 `SETTINGS`帧中设定服务端流的值为0，禁用此功能
-    `PUSH_PROMISE`帧中只包含预推送资源的首部。如果客户端对` PUSH PROMISE`帧没有意见，服务端在 `PUSH PROMISE`帧后发送响应的`DATA`帧开始推送资源。如果客户端已经缓存该资源,不需要再推送,可以选择拒绝 `PUSH PROMISE`帧。

##### 限制

-   所有推送的资源必须遵守同源策略
-   `PUSH_PROMISE`必须遵循请求-响应原则，只能借着对请求的相应推送资源。
-   `PUSH_PROMISE`帧必须在返回响应之前发送，以免客户端出现竞态条件

#### 4.3.4 首部压缩

**HTTP1.x**: 每次通信(请求/响应)都会携带大量首部信息用于描述资源性，且每次都要重复发送。

**HTTP2.0**：在客户端和服务端之间使用“首部表”来跟踪和存储之前发送的键值对，首部表在连接过程中始终存在，新增的键值对会更新到表尾，因比，避免了重复头部的传输，又减小了需要传输的大小。

​		HTTP2.0使用了首部压缩技术,可让报头更紧凑、更快速传输。HTTP2.0关注的是首部压缩,而我们常用的gzp等是报文内容(body)的压缩。

### 4.4 传输协议

TCP

### 4.5 缺点

#### 4.5.1 TCP队头阻塞问题

​		HTTP/2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；

#### 4.5.2 TCP建立连接的延时

​		发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。

​	另外， TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生"减速"效果。

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203151653476.jpeg)



#### 4.5.3 网络迁移需要重新链接

​	移动设备从4G网络环境切换到WIFI时，由于TCP是基于四元组（源IP地址，源端口，目标IP地址，目标端口）来确认一条TCP链接的，那么网络环境变换后，就会导致IP地址或端口变换，于是TCP只能断开连接，然后重新建立连接，切换网络环境成本高。



## 5 HTTP3.0

### 5.1 简介

​	我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。

而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。

当然，HTTP/3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 **QUIC 协议**，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。

### 5.2 特点

#### 5.2.1 快速握手

:::tip

总结： 

http2 : 先TCP握手，再TLS握手

http3: QUIC协议并不与TLS分层

:::

​	对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

​	**QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果**。

![图片描述](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111091857304.webp)



#### 5.2.2 多路复用

​		QUIC保留了HTTP2.0多路复用的特性，但是即使在多路复用过程中，同一个TCP连接上有多个stream，假如其中一个stream丢包，在重传前后续的stream都会受到影响，而QUIC中一个连接上的多个stream之间没有依赖。所以当发生丢包时，只会影响当前的stream，也就避免了线头阻塞问题。

#### 5.2.3 优化重传策略

**TCP丢包重传**：在发送端为每一个封包标记一个编号 (`sequence number`)，接收端在收到封包时，就会回传一个带有对应编号的ACK封包给发送端，告知发送端封包已经确实收到。当发送端在超过一定时间之后还没有收到回传的 ACK，就会认为封包已经丢失，启动重新传送的机制，复用与原来相同的编号重新发送一次封包，确保在接收端这边没有任何封包漏接。这样的机制就会带来一些问题，假设发送端总共对同一个封包发送了两次 (初始 + 重传)，使用的都是同一个sequence number：编号N。之后发送端在拿到编号N封包的回传ACK 时，将无法判断这个带有编号N的ACK，是接收端在收到初始封包后回传的ACK。这就会加大后续的重传计算的耗时。

**QUIC丢包重传**： QUIC为了避免这个问题，发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，`unique packet number`，每一个编号都唯一而且严格递增，这样每次在收到ACK时，就可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。

#### 5.2.4 流量控制

​		通过流量控制可以限制客户端传输资料量的大小，有了流量控制后，接收端就可以只保留相对应大小的接收` buffer`，优化记忆体被占用的空间。但是如果存在一个流量极慢的`stream` ，光一个`stream`就有可能占用掉接收端所有的资源。QUIC为了避免这个潜在的HOL Blocking，采用了连线层 (`connection flow control`) 和 Stream 层的 (`stream flow control`) 流量控制，限制单一 `Stream` 可以占用的最大`buffer size`。

#### 5.2.5  **连接迁移**

**TCP连接**：基于四元组（源 IP、源端口、目的 IP、目的端口），切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的 TCP 连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的 TCP 连接，即使这样，建立新的连接还是需要几百毫秒的时间。

**QUIC连接**：不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 `Connection ID`，对应每个stream，即使 IP 或者端口发生变化，只要 `Connection ID` 没有变化，那么连接依然可以维持。



#### 5.2.6 集成了TLC加密功能



#### 5.2.7 无对头阻塞

### 5.3 传输层协议

​		UDP

### 5.4 存在挑战

-   服务器和浏览器端都没有对HTTP/3.0提供比较完整的支持
-   部署HTTP/3.0也存在着非常大的问题，因为系统对UDP优化还不是很好
-   中间设备僵化问题，这些设备对UDP的优化程度远低于TCP

## 总结

| 协议版本 |           解决核心问题 |                解决方式                |
| :------: | ---------------------: | :------------------------------------: |
|   0.9    |           HTML文件传输 | 确立了客户端请求、服务端响应的通信流程 |
|   1.0    |       不同类型文件传输 |              设立头部字段              |
|   1.1    | 创建/断开TCP连接开销大 |           建立长连接进行复用           |
|   2.0    |             并发数有限 |               二进制分帧               |
|   3.0    |            TCP丢包阻塞 |              采用UDP协议               |

​	

## 参考

1.   [HTTP发展史（HTTP1.1，HTTPS，SPDY，HTTP2.0，QUIC，HTTP3.0）](https://juejin.cn/post/6844903988953874445#heading-0)
2.   [六张图从HTTP/0.9进化到HTTP3.0](https://juejin.cn/post/6856036933723521032)
3.   [百度百科](https://baike.baidu.com/item/HTTP/243074?fr=aladdin#2)
3.   [http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记](https://juejin.cn/post/6844904001528397837)
3.   [HTTP发展史](https://zhuanlan.zhihu.com/p/293378068)

