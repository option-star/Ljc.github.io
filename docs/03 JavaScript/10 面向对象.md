---
title: JS10面对对象
date: 2022-03-19
sidebar: 'auto'
categories:
- 03JavaScript
isShowComments: true
---

## 01 对象创建的方式有哪些？

一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：
（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。
（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。
（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。
（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。
（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。
（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。

## 02 对象继承的方式有哪些？



### 1. 封装、继承、多态

​	JS本身是基于面向对象开发的编程语言。类具备封装、继承与多态。

- **封装**：类也是一个函数，把实现一个功能的代码进行封装，以此实现“低耦合高内聚”
- **多态**：重载、重写
  - 重写： 子类重写父类上的方法（伴随着继承运行的）
  - 重载： 相同的方法，由于参数或者返回值不同，具备了不同的功能（JS中不具备严格意义上的重载，JS中的重载：同一个方法内，根据传参不同实现不同的功能）
- **继承**：子类继承父类的方法

### 2. 继承的目的

让子类的实例同时具备父类中私有的属性和公共的方法

### 3. 原型继承

​	让子类的原型等于父类的实例。子类的实例，能够用子类私有的和原型上公有的。父类的实例，可以使用父类私有的和原型上公有的。

```js
/* 原型继承 */
Child.prototype = new Parent; 
```

![原型继承](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203202028600.png)

特点：

1. 父类中私有和公有的属性方法，最后都变为子类实例公有的。
2. 和其他语言不同的是，原型继承并不会把父类的属性或方法“拷贝”给子类，而是让子类实例基于`__proto__`原型链找到自己定义的属性和方法。（指向、查找方式的）。

### 4. CALL继承

**CALL继承**：在子类构造函数中，把父类当作普通方法执行（没有父类实例，父类原型上的那些东西也就和它没有关系了）

核心代码如下：

```js
function Child () {
    // 让子类的实例继承了父类的私有的属性，并且也变为了子类私有属性(拷贝式的)
    Parent.call(this);
}
```

特点：

1. 只能继承父类中私有的，不能继承父类中共有的。
2. 把父类中私有的，变成子类私有的。

### 5. 寄生组合式继承

**寄生组合式继承**：CALL继承 + 另类原型继承

核心代码如下：

```js
function Child() {
    // 让父类私有的变成子类私有的
    Parent.call(this);
}
// 让父类公有的变成子类公有的
Child.prototype.__proto__ = Parent.prototype; // 法一：  IE不兼容

// 创建一个空对象，让其原型链指向Parent.prototype
Child.prototype = Object.create(Parent.prototype) // 法二： IE兼容
Child.prototype.constructor = Child; // 法二： 保证完整性
```

方法一：

```js
Child.prototype.__proto__ = Parent.prototype; // 法一
```

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203202028973.png)

方法二：

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203202028298.png)

### 6. ES6中的继承

核心代码如下：

```js
class Child extends Parent {
    constructor() {
        super() // => 类似于CAll继承
        /* super(100，200):相当于把Parent中的constructor执行，传递了100和200*/
    }
}
```

注意：

1. 继承后一定要在constructor第一行加上super。
2. ES6创建的就是类，不能当作普通函数执行，只能new执行。

### 7. 从设计思想上谈谈继承本身的问题

假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。

```js
class Car{
  constructor(id) {
    this.id = id;
  }
  drive(){
    console.log("wuwuwu!");
  }
  music(){
    console.log("lalala!")
  }
  addOil(){
    console.log("哦哟！")
  }
}
class otherCar extends Car{}
```

现在可以实现车的功能，并且以此去扩展不同的车。

但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。

如果让新能源汽车的类继承Car的话，也是有问题的，俗称"大猩猩和香蕉"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。

> 继承最大的问题在于：无法决定继承哪些属性，所有属性都得继承。

当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，`代码势必会大量重复`，另一方面一旦子类有所变动，父类也要进行相应的更新，`代码的耦合性太高`，维护性不好。

那如何来解决继承的诸多问题呢？

用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。

顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。

```js
function drive(){
  console.log("wuwuwu!");
}
function music(){
  console.log("lalala!")
}
function addOil(){
  console.log("哦哟！")
}

let car = compose(drive, music, addOil);
let newEnergyCar = compose(drive, music);
```

代码干净，复用性也很好。这就是面向组合的设计方式。

