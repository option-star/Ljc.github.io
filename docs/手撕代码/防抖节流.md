---
title: 防抖节流
date: 2021-11-11
sidebar: 'auto'
tags:
- 防抖节流
categories:
- 手撕代码
isShowComments: true
---

## 1. 简介

-   **防抖**： 在频繁触发下，只识别“一次”
-   **节流**： 减低触发频率，它能识别多次[浏览器有自己的最快反应事件，例如谷歌5~7ms,这样在我们疯狂操作下，谷歌浏览器的频率是5ms执行一次，节流就是减低这个频率，比如设定频率是300ms, 在疯狂触发的时候，我们间隔300ms才能执行一次]

## 2. 应用场景

-   点击事件一般以防抖为主
-   键盘输入事件或者滚动事件，一般以节流为主

## 3. 防抖实现

```js
/**
 * 函数防抖
 * @param {*} func : 最后要执行的函数
 * @param {*} wait : 触发的频率
 * @param {*} immediate : true:执行第一次，false: 执行最后一次
 * @return func执行的返回结果
 */
function debounce (func, wait, immediate) {
    // 容错
    if(typeof func !== "function") throw new TypeError('func must be required and be an function');
    if (typeof wait === "boolean") {
        immediate = wait;
        wait = 300;
    }
    if (typeof wait !== "number") wait = 300;
    if (typeof immediate !== "boolean") immediate = false;
    
    /* setTimeout的返回值是一个数字，表示设置的第几个定时器 */
    let timer = null; // 定时器
    let result; // 对结果处理
    return function proxy (...params) {
        /*let params = [].slice.call(arguments)*/
        let runNow = !timer && immediate; // 用于immediate参数处理
        if (timer) clearTimeout(timer); // 若定时器已经存在则清除之前的定时器
        timer = setTimeout(function () {
            if (timer) { // 定时器执行完成之后，清除当前定时器
                clearTimeout(timer);
                timer = null;
            };
            !immediate? result = func(...params) : null;
            /* func.apply(this, params) */
        }, wait);
        runNow ? result = func(...params) : null;
        return result;
    };
}

box.onclick = debounce(fn, 300, true); 
```

## 4. 节流实现

```js
/*
 * throttle: 函数节流
 * @params
 *    func [function,required] : 最后要执行的函数
 *    wait [number] : 设定的频率触发的频率时间，默认值是300 
 * @return
 *    func执行的返回结果
 */
 function throttle (fnc, wait) {
    if(typeof func !== "function") throw new TypeError('func must be required and be an function');
    if (typeof wait !== "number") wait = 300;
    
    let timer = null, // 定时器
        previous = 0, // 记录上次的触发时间
        result;
     return function proxy() {
         let now =  +new Date(), // 当前时间值
             remaining = wait - (now - previous), // 到达触发时间的剩余时间
             self = this,
             params = [].slice.call(arguments); // func函数的实参集合
         if (remaining <= 0) {
             if (timer) { // 清除定时器
                 clearTimeout(timer);
                 timer = null;
             }
             //立即执行
             result = func.apply(self, params);
             previous = +new Date();
         } else if (!timer) { 
             // 没有达到间隔时间，而且之前没有设置过定时器，此时我们设置定时器，等到remaining后执行一次
             timer = setTimeout(function () {
                 if (timer) { // 清除定时器
                     clearTimeout(timer);
                     timer = null;
                 }
                 result = func.apply(self, params);
                 previous = +new Date();
             },remaining);
         }
     }
     return result;
 }

window.onscroll = throttle(fn, 500);
```

