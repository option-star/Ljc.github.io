## 1. 回流和重绘的概念与触发条件

### 1） 回流

​	当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为**回流**。

下面这些操作会导致回流：

- 页面的**首次渲染**
- 浏览器的**窗口大小**发生变化
- 元素的**内容**发生变化
- 元素的**尺寸或者位置**发生变化
- 元素的**字体**大小发生变化
- 激活**CSS伪类**
- **查询某些属性**或者调用某些方法
- 添加或者删除可见的**DOM**元素

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：

- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局



### 2） 重绘

当页面中某些元素的**样式发生变化**，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是**重绘**。

下面这些操作会导致回流：

- color、background 相关属性：background-color、background-image 等
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow

注意： **当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。**



## 2. 如何避免回流与重绘

**减少回流与重绘的措施：**

- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- **使用absolute或者fixed**，使元素脱离文档流，这样他们发生变化就不会影响其他元素
- **避免频繁操作DOM**，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素先**设置`display: none`**，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**

​	**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**

​	上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。



## 3. 如何优化动画

​	对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就会导致页面的性能问题，我们可以将动画的`position`属性设置为`absolute`或者`fixed`，将动画脱离文档流，这样他的回流就不会影响到页面了。



## 4. documentFragment是什么？用它跟直接操作DOM的区别是什么？

- **定义**： DocumentFragment，是一个没有父对象的最小文档对象，并且DocumentFragment不是真实DOM树的一部分，所以变化不会触发DOM树的重新渲染。

​	当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将**DocumentFragment** 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。

