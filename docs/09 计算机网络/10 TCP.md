---
title: 计网10 TCP
date: 2022-03-31
sidebar: 'auto'
categories:
- 09计网
isShowComments: true
---

## 1. TCP头格式

> TCP头部格式

![TCP 头格式](https://cdn.jsdelivr.net/gh/option-star/imgs/202204080741087.png)

- **序列号**： 在建立连接时由计算机生成的随机数作为其初始值。用来解决网络包乱序问题。

- **确认应答号**： 指下次期望收到的数据的序列号，发送端收到后可以认为这个序列号之前的数据被正常接收，用来解决丢包问题。

- **控制位**

  - `ACK`: 该位为1时，确认应答的字段变为有效
  - `RST`:该位为1时，表示TCP连接中出现异常必须强制断开连接
  - `SYN`:该位为1时，表示希望建立连接 
  - `FIN`: 该位为1时，表示希望断开连接

  

## 2. 为什么需要TCP协议？

**结论**： 保障网络数据包的可靠性

​	`IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

​	如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 `TCP` 协议来负责。



## 3. 什么是TCP？

TCP是面向连接的、可靠的、基于字节流的传输层通信协议。

- **面向连接**：表示一对一连接
- **可靠的**：保证一个报文一定能够到达接收端
- **字节流**：消息没有边界，并且消息是有序的。



## 4. 什么是TCP连接？

> 连接的定义

**连接**： 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括socket、序列号和窗口大小称为连接

> 建立一个TCP的三个条件

- Socket: 由IP地址和端口号组成
- 序列号：用来解决乱序问题等
- 窗口大小：用来做流量控制



## 5. 如何确定一个TCP连接呢？

![TCP 四元组](https://cdn.jsdelivr.net/gh/option-star/imgs/202204080821293.png)

- 源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

- 源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

## 6. 有一个IP的服务器监听了一个端口，它的TCP的最大连接数是多少？

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204080823602.png)

> IPv4

IP数： `2^32`

端口数： `2^16`

最大TCP连接数： `2^48`

> 受限

- **文件描述符**： 每个TCP连接都是一个文件，如果文件描述符被占满了 ，会发生`too many open files`
- **内存限制**： 每个TCP连接都占用一定的内存，而操作系统的内存有限，如果内存资源被占满会发生OOM（内存泄漏）。



## 7. UDP头部格式

![UDP 头部格式](https://cdn.jsdelivr.net/gh/option-star/imgs/202204080831792.png)

- **目标和源端口**： 主要告诉UDP协议应该把报文发给哪个进程
- **包长度**： 该字段保存了UDP首部的长度和数据的长度之和
- **校验和**： 防止收到的网络传输中受损的UDP包



## 8. UDP与TCP的区别

|                    |                          TCP                          |                           UDP                           |
| :----------------: | :---------------------------------------------------: | :-----------------------------------------------------: |
|        连接        |                 传输数据前先建立连接                  |                不需要连接，即刻传输数据                 |
|      服务对象      |                   一对一，两个端点                    |                 一对一、一对多、多对多                  |
|       可靠性       |                     可靠交付数据                      |               尽最大努力交付，不保证可靠                |
| 拥塞控制、流量控制 |               具有，保证数据传输的安全                |                          没有                           |
|      首部开销      |            没有使用选项时，20字节，开销大             |               8字节，长度固定不变，开销小               |
|      传输方式      |         流式传输，没有边界，但保证顺序和可靠          |       一个一个包发送，有边界，但可能会丢包和乱序        |
|      分片不同      | 大于MSS大小，会进行分片，中途丢失，只需传输丢失的分片 |                   大于MTU，会进行分片                   |
|      应用场景      |                 `FTP`文件传输、HTTPS                  | 包总量较少的通信`DNS`、视频、音频等多媒体通信、广播通信 |

## 9. 为什么TCP具有首部字段，而UDP没有

因为TCP有可变长字段——选项，而UDP首部长度不变，无需多一个字段记录UDP首部长度



## 10. 为什么UDP头部有包长度字段，而TCP没有呢？

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204080901738.png)

**因为为了网络设备硬件设计和处理方便，首部长度需要`4`字节的整数倍**



## 11. TCP三次握手过程和状态变迁

![TCP 三次握手](https://cdn.jsdelivr.net/gh/option-star/imgs/202204080904421.png)

1. 一开始，客户端和服务端处于`ClOSED`状态。先是服务端主动监听某个端口，处于`LISTEN`状态
2. 客户端会随机初始化序列号`client_isn`，将该序号置于TCP首部的[序号]字段中，同时把`SYN`标志位置为1，表示`SYN`报文。然后把SYN包发送给服务端，之后客户端处于`SYN—SENT`状态
3. 服务端收到客户端的`SYN`报文后，首先服务端也随机初始化自己的序号`server_isn`， 将此序号填入TCP首部的[序号]字段中，其次把TCP首部的[确认应答号]字段填入`client_isn + 1`, 接着把`SYN`和`ACK`标志位置为`1`。最后把报文发给客户端，之后服务端处于`SYN_REVD`状态
4. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，ACK置为1，确认应答号填入`server_isn + 1`，发送报文给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于`ESTABLISHED`状态。
5. 服务器收到客户端的应答报文后，也进入`ESTABLED`状态。



## 12. 为什么是三次握手？不是两次？四次？

TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。

- **两次握手**： 无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号。
- **四次握手**：三次握手就可以理论上最少可靠连接建立，所以不需要使用更多的通讯次数。

> 防止历史连接的建立

场景：客户端连续发送多个SYN建立连接的报文，在网络拥堵的情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。

​	**在两次握手的情况下，[被动发起方]没有中间状态给[主动发起方]来阻止历史连接，导致[被动发起方]可能建立一个历史连接，造成资源浪费。**

> 同步双方初始序列号

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

两次握手只保证了一方的初始化序列号能被对方成功接收，没法保证双方的初始序列号都能被确认接收。

> 避免资源浪费

如果客户端的`SYN`阻塞了，重复发送多次`SYN`报文，那么服务器在收到请求后就会建立多个冗余的无效连接，造成不必要的资源浪费



## 13. 为什么每次建立TCP连接时，初始化的序列号都要求不一样呢？

- 如果每次建立连接，客户端和服务端的初始化序列号都一样的化，很容易出现历史报文被下一个相同的四元组的连接接收的问题。
- 为了安全性，防止黑客伪造的相同序号的TCP报文被对方接收

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204081403047.png)



## 14. 初始序列号的ISN是如何随机产生的？

初始化序列号随机生成算法： ISN = M + F

- M是一个计时器，这个计时器**每隔4微秒+1**
- F是一个Hash算法，根据**源IP、目的IP、源端口、目的端口**生成一个随机数。
  

## 15. MTU和MSS

![MTU 与 MSS](https://cdn.jsdelivr.net/gh/option-star/imgs/202204081414268.png)

- `MTU`: 一个网络包的最大长度，以太网中一般为`1500`字节
- `MSS`： 除去IP和TCP头部之后，一个网络包所能容纳的TCP数据最大的长度。



## 16. 既然IP层会分片，为什么TCP层还需MSS呢？

> 如果直接将整个报文传给IP

​	当一个数据超过MTU后，IP会对数据进行分片，如果一个分片丢失，整个IP报文的所有分片都得重传。

> 如果由TCP负责超时重传

​	当接收方发现TCP报文的某一片丢失后，则不会响应ACK给对方，那么发送方的TCP在超时后，就会重发整个TCP报文



## 17. 第一次握手丢失了，会发生什么？

如果第一次握手丢失了，也就是说客户端迟迟收不到服务端的SYN-ACK报文（第二次握手），就会触发[ **超时重传** ]机制，重传SYN报文。而且每次超时的时间是上一次的两倍。



## 18. 第二次握手丢失了，会发生什么？

由于第二次握手丢失： 

- 客户端迟迟没有收到第二次握手，客户端认为是自己的SYN报文丢失，于是**客户端就会触发超时重传机制，重传SYN报文**
- 由于服务端迟迟没有收到第三次握手，于是**服务端这边会触发超时重传机制，重传SYN-ACK报文。**



## 19. 第三次握手丢失了，会发生什么？

​	如果第三次握手丢失了，服务端迟迟没有收到确认报文，就触发超时重传机制，**重传SYN-ACK报文**，直到收到第三次握手，或者达到最大重传机制。



## 20. TCP四次握手过程和状态变迁

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.jsdelivr.net/gh/option-star/imgs/202204082301380.png)

- 客户端打算关闭连接，此时会发送一个TCP首部FIN标志位被置为1的报文，之后客户端进入`FIN_WAIT_1`状态
- 服务端收到该报文后，就向客户端发送`ACK`应答报文，接着服务端进入`CLOSED_WAIT`状态。
- 客户端收到服务端的`ACK`应答报文后，之后进入`FIN_WAIT_2`状态。
- 等待服务端处理完数据后，也向客户端发送`FIN`报文，之后服务端进入`LAST_ACK`状态。
- 客户端收到服务端的`FIN`报文后，回一个`ACK`应答报文，之后进入`TIME_WAIT`状态。
- 服务端收到了`ACK`应答报文后，就进入`CLOSED`状态，至此服务端已经完成连接的关闭。
- 客户端在经过`2MSL`一段时间后，自动进入`CLOSED`，至此客户端完成连接 的关闭。



## 21. 为什么挥手需要四次？

​	服务端通常需要等待完成数据的发送和处理，所以服务端的`ACK`和`FIN`一般都会分开发送，从而比三次握手导致多了一次。



## 22. 第一次挥手丢失了，会发生什么？

​	如果第一次挥手丢失了，那么客户端迟迟收不到被动方的ACK的话，也就会触发超时重传机制，重传FIN报文。一旦超过重传的次数，就不会发送FIN报文，直接进入到`CLOSE`状态。



## 23. 第二次挥手丢失了，会发生什么？

​	如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传`FIN`报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。



## 24. 第三次挥手丢失了，会发生什么？

​	如果服务端的第三次挥手丢失了，也就是说服务端迟迟没有收到客户端的`ACK`报文，服务端就会重发`FIN`报文。



## 25. 第四次挥手丢失了，会发生什么？

如果第四次挥手丢失了，也就是服务端迟迟没有收到对应的`ACK`报文，服务端就会重发`FIN`a报文。



## 26. MSL是什么？

​	MSL， 报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。



## 27.  为什么TIME_WAIT等待的时间是2MSL？

​		网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。

​		比如，如果被动关闭方没有收到断开连接的最后的ACK报文，就会触发超时重发`FIN`报文，另一方接收到FIN后，会重发ACK给被动关闭方，一来一去正好2个MSL。

## 28. 为什么需要`TIME_WAIT`状态？

主动发起关闭连接的一方，才会有`TIME_WAIT`状态。

需要TIME_WAIT状态，主要是两个原因：

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
- 保证[ 被动关闭连接  ] 的一方，能被正确地关闭。

## 29. TIME_WAIT过多有什么危害？

- 内存资源占用；
- 对端口资源的占用，一个TCP连接至少消耗 [ 发起连接方 ] 的一个本地端口。当占满了所有的端口资源，则会导致无法创建新连接。

## 30. 如果建立了连接，但是客户端突然出现故障了怎么办？

TCP有一个**保活机制**，机制原理：

​	定义一个时间端，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前 的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。



## 31. 如果已经建立了连接，但是客户端的进程崩溃会发生什么？

​	进程奔溃了，服务端会发送`FIN`报文，与客户端进行四次挥手。



## 32. TCP重传机制

常见的重传机制：

- 超时重传
- 快速重传
- SACK
- D-SACK



## 33. 超时重传是什么？

**超时重传**： 在发送数据时，设定一个定时器，当超过指定时间后，没有收到对方的`ACK`确认应答报文后，就会重发该数据。

**发生超时重传的情况**：

- 数据包丢失
- 确认应答丢失

**超时重传时间（RTO）设置**： RTO的值应该略大于报文往返RTT的值

- 如果较大： 重发就慢，没有效率，性能差
- 如果较小：没有丢就重发，会增加网络拥塞。

**重传策略**： 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。



## 34. 有了超时重传，为什么还要快速重传？

​	超时重传存在的问题是，超时周期可能相对较长。如果想要更快的方式，就是快速重传。



## 35. 快速重传是什么？

**快速重传机制**： 不以时间为驱动，而是以数据驱动重传。

**工作方式**： 当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的片段。

**问题**： 重传的时候，是重传之前的一个，还是重传所有的问题。

为了解决不知道该重传哪些TCP报文，于是就有了`SACK`方法。



## 36. SACK方法是什么？

**SACK** (选择性确认)： 在TCP头部【选项】字段里加一个`SACK`的字段，它**可以缓存的map发送给发送方**，这样发送方就可以直到哪些数据收到了，哪些数据没有收到，直到这些信息后，就可以只**重传丢失的数据**。



## 37. 什么是`D-SACK`

`D-SACK`: 主要使用了SACK来告诉发送方有哪些数据被**重复**接收了。

**好处**：

- 可以让发送方知道是发出去的包丢了，还是接收方回应的ACK包丢了
- 可以知道是不是发送方的数据包被网络延迟了
- 可以知道网络中是不是把发送方的数据包赋值了



## 38. 为什么引入窗口？

​	TCP是每发送一个数据，都要进行一次确认应答。当上一个数据包收到应答后，再发送下一个。这样为每个数据包确认应答的缺点：**数据包的往返时间越长，通信效率就越低。**

​	有了窗口后，就可以指定窗口大小，窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

​	窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓存区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓冲区清除。



## 39. 窗口大小由哪一方决定？

TCP头里有一个字段叫`window`，也就是窗口大小。

​	这个字段是接收端告**诉发送端自己还有多少缓冲区可以接收数据**。于是发送端就可以根据这个接收端的处理能力发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由**接收方的窗口大小**来决定的。



## 40.接收窗口和发送窗口的大小是相等的吗？

并不是完全相等，接收窗口的大小是约等于发送窗口的大小 。

因为滑动窗口动态的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。



## 41. 发送方的滑动窗口

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204090956759.jpeg)



## 42. 接收方的滑动窗口

![接收窗口](https://cdn.jsdelivr.net/gh/option-star/imgs/202204090957489.jpeg)



## 43. 为什么需要流量控制

​	发送方不能无脑的发数据给接收方，要考虑接收方处理能力。否则，当对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

 所以，**TCP提供了一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制**。



## 44. 什么是窗口关闭？

​	如果窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非零为止，这就是窗口关闭。

​	

## 45. 窗口关闭的潜在问题

​	当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非0的ACK报文，如果通告窗口的ACK报文在网络中丢失了，会导致发送方一直等待接收方的非0窗口通知，接收方也一直等待发送方的数据，如果不采取措施，这样相互等待的过程，会造成死锁的现象。



## 46. TCP如何解决窗口关闭时，潜在的死锁现象？

​	为了解决死锁现象，TCP为每个连接设有一个持续定时器，**只要TCP连接 一方收到对方的零窗口通知，就会启动持续计时器**。

​	如果持续计时器超时，就会发送**窗口探测报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口。

​	探测窗口的次数一般为3次，每次大约30~60秒。如果三次过后接收窗口还是0的话，有的TCP实现就会发`RST`报文来中断连接。



## 47. 什么是糊涂窗口综合症

​	如果接收方太忙，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。

​	到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。

所以，糊涂窗口综合症的现象发生在发送方和接收方：

- 接收方可以通告一个小窗口
- 而发送方可以发送小数据



## 48. 怎么让接收方不通告小窗口呢？

接收方通常的策略如下:

​	当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。

​	等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。



## 49. 怎么让发送方避免发送小数据呢？

发送方通常的策略:

使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：

- 要等到窗口大小 >= `MSS` 或是 数据大小 >= `MSS`
- 收到之前发送数据的 `ack` 回包

只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。

## 50. 为什么要有拥塞控制？不是有流量控制了吗？

**流量控制**： 避免发送方的数据填满接收方的缓存，但不知道网络中发生什么

**拥塞控制**： 避免发送方的数据填满整个网络。

​	在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包的时延、丢失等，这时TCP就会重传数据，但是一重传就会导致网络的负担更重，于是导致更大的延迟以及更多的丢包 ，这个情况就会进入恶性循环被不断地放大…



## 51. 什么是拥塞窗口？和发送窗口有什么关系？

**拥塞窗口cwnd** ： 发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化。

**发送窗口大小** = min（**接收窗口大小**， **拥塞窗口大小** ）

**拥塞窗口大小变化规则**：

- 只要网络没有出现拥塞，窗口变大
- 网络出现拥塞，窗口变小



## 52. 怎么知道当前网络是否出现了拥塞了呢？

发生了超时重传，就会认为网络出现了拥塞



## 53. 拥塞控制有哪些控制算法？

主要四个算法：

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复



## 54. 什么是慢启动

**慢启动规则**： 当发送方**每收到一个ACK**, 拥塞窗口cwnd的大小就会加**1**。

![慢启动算法](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091106459.jpeg)



## 55. 慢启动涨到什么时候是个头呢？

慢启动门限`ssthresh`（slow start threshold）状态变量：

- `cwnd` < `ssthresh`时，使用慢启动算法。
- `cwnd` >= `ssthresh`时，使用拥塞避免算法。



## 56. 什么是拥塞避免算法

**拥塞避免算法规则**： 每当收到一个ACK时，cwnd增加1 / cwnd。（线性增长）

![拥塞避免](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091114196.jpeg)



## 57. 什么是拥塞发生算法？

当触发了重传机制，就会进入拥塞发生算法。

> 发生超时重传的拥塞发生算法

- `ssthresh`设为`cwnd / 2`
- `cwnd`重置为1

![拥塞发送 —— 超时重传](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091119323.jpeg)



> 发生快速重传的拥塞发生算法

- `cwnd = cwnd / 2`, 设置为原本的一半
- `ssthresh = cwnd`；
- 进入快速恢复算法



## 58. 什么是快速恢复算法

快速恢复算法规则：

- 拥塞窗口`cwnd = ssthresh + 3`
- 重传丢失的数据包
- 如果再收到重复的ACK，那么cwnd  + 1
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；



## 59. 什么是TCP半连接队列和全连接队列

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；

​	服务端收到客户端发起的 SYN 请求后，**内核会把该连接存储到半连接队列**，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，**内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。**

​	不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。



![半连接队列与全连接队列](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091128377.jpeg)



## 60. 在没有开启TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的主机奔溃了，会发生什么？

​	客户端主机奔溃了，服务端是无法感知的，再加上服务端没有开启TCP keepalive，又没有数据交互的情况下，服务端的TCP连接将会一直处于ESTABLISHED连接状态，直到服务端重启进程。



## 61. 为什么UDP是面向报文的协议？

当用户消息通过UDP协议传输时，**操作系统不会对消息进行拆分**，**每个UDP就是一个用户消息的边界**。



![图片](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091148801.png)



## 62. 为什么TCP是面向字节流的协议？

当用户消息通过TCP协议传输时，**消息可能会被操作系统分组成多个的TCP报文**，也就是**一个完整的用户消息被拆分成多个TCP报文进行传输**。



## 63. 如何解决粘包？

### 1） 固定长度消息

​	即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。



### 2）特殊字符作为边界

​	在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。

![图片](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091159054.png)

### 3） 自定义消息结构

我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。

比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。

```c
struct { 
    u_int32_t message_length; 
    char message_data[]; 
} message;
```
