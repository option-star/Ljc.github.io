---
title: 计网09 输入url
date: 2021-12-15
sidebar: 'auto'
categories:
- 09计网
isShowComments: true
---



![简单的网络模型](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091318167.png)



![](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100830386.png)



## 1. 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL。

- 如果是**搜索内容**，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
- 如果是**URL**， 会判断输入内容是否如何URL规则，如果不符合地址栏会根据规则，合成完整的URL。



## 2. 解析URL

​	对 `URL` 进行解析，解析之后，浏览器确定了Web服务器和文件名，然后通过这些信息来生成HTTP请求信息。

> HTTP请求消息

![HTTP 的消息格式](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091318655.png)





## 3. 本地缓存

​	网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源直接返回资源给浏览器进程；如果缓存中没有查找到资源，那么进入网络请求流程。

![业务流程图1.png](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100851110.webp)

1. 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；

2. 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 **cache-control** 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 **expires** 头判断是否过期；

3. 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；

4. 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；

5. 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；



## 2. 真实地址查询–DNS

​	发送信息之前，会先去那**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

​	所以，有一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS` 服务器。

![域名解析的工作流程](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091318611.png)

- 首先搜索**浏览器的 DNS 缓存**，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索**操作系统的 DNS 缓存**(host文件)
- 若仍然没有命中，则操作系统将域名发送至**本地域名服务器**，本地域名服务器采用**递归查询**自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向**根域名服务器**发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个**顶级域名服务器**的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据**权限域名服务器**的地址向其发起请求，最终得到该域名对应的 IP 地址
- **本地域名服务器将**得到的 IP 地址返回给操作系统，同时自己将 IP 地址**缓存起来**
- **操作系统**将 IP 地址返回给浏览器，同时自己也将 IP 地址**缓存起来**
- 至此，**浏览器**就得到了域名对应的 IP 地址，并将 IP 地址**缓存起来**



## 3. 协议栈

​	通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。



![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091319956.png)

## 4. 等待TCP队列

​	由于Chrome有个机制，同一个域名同时最多之只能建立6个TCP连接，如果同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。

​	如果当前请求数量少于6，会直接进行建立TCP连接。



## 4. TCP三次握手

![TCP 三次握手](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100825412.png)

1. 一开始，客户端和服务端处于`ClOSED`状态。先是服务端主动监听某个端口，处于`LISTEN`状态
2. 客户端会随机初始化序列号`client_isn`，将该序号置于TCP首部的[序号]字段中，同时把`SYN`标志位置为1，表示`SYN`报文。然后把SYN包发送给服务端，之后客户端处于`SYN—SENT`状态
3. 服务端收到客户端的`SYN`报文后，首先服务端也随机初始化自己的序号`server_isn`， 将此序号填入TCP首部的[序号]字段中，其次把TCP首部的[确认应答号]字段填入`client_isn + 1`, 接着把`SYN`和`ACK`标志位置为`1`。最后把报文发给客户端，之后服务端处于`SYN_REVD`状态
4. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，ACK置为1，确认应答号填入`server_isn + 1`，发送报文给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于`ESTABLISHED`状态。
5. 服务器收到客户端的应答报文后，也进入`ESTABLED`状态。



> 网络包报文

![TCP 层报文](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091319864.png)





## 5. 远程定位 IP

​	TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

![IP 层报文](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091319292.png)



## 6. 两点传输 - MAC

​	在生成了IP头部之后，就获取MAC地址

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

网络包还需要在IP头部的前面加上MAC头部。

​	在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

​	一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

 

![MAC 层报文](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091319474.png)



## 7. 出口——网卡

​	网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，通过**网卡**将**数字信息转换为电信号**：

​	网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。最后网卡将包转为电信号，通过网线发送出去。

![数据包](https://cdn.jsdelivr.net/gh/option-star/imgs/202204091319966.png)



## 8. 送别者 —— 交换机

​	电信号到达网线接口，交换机的模块将电信号转换为数字信号，然后通过包末尾的FCS校验错误，如果没有问题则放到缓冲区

​	将包放入缓冲区后，查询这个包的接收方的MAC地址是否已经在MAC地址表中有记录：

- 如果有记录，将信号发送到相应的端口
- 如果没有记录，将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。

![交换机的 MAC 地址表](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100933379.jpeg)



## 9. 出境大门 —— 路由器

​	当转发包时，首先路由器端口会接收发给自己的以太网包，然后 **路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

:::tip

​	在网络包传输过程中，

:::

![路由器转发](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100942548.jpeg)



> 路由器与交换机的区别

- 路由器是基于IP设计的，俗称三层网络设备，路由器的各个端口都具备MAC地址和IP地址
- 交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具备MAC地址



## 10. 服务器

![网络分层模型](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100913765.jpeg)

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100845153.png)





## 11. TCP四次挥手

​	通常情况下，一旦服务器向客户端返回了请求数据，它就要断开TCP连接。不过如果浏览器或者服务器在其头部信息加入了：`Connection：Keep-Alive`。

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100832792.png)

1. 客户端打算关闭连接，此时会发送一个TCP首部FIN标志位被置为1的报文，之后客户端进入`FIN_WAIT_1`状态
2. 服务端收到该报文后，就向客户端发送`ACK`应答报文，接着服务端进入`CLOSED_WAIT`状态。
3. 客户端收到服务端的`ACK`应答报文后，之后进入`FIN_WAIT_2`状态。
4. 等待服务端处理完数据后，也向客户端发送`FIN`报文，之后服务端进入`LAST_ACK`状态。
5. 客户端收到服务端的`FIN`报文后，回一个`ACK`应答报文，之后进入`TIME_WAIT`状态。
6. 服务端收到了`ACK`应答报文后，就进入`CLOSED`状态，至此服务端已经完成连接的关闭。
7. 客户端在经过`2MSL`一段时间后，自动进入`CLOSED`，至此客户端完成连接 的关闭。



## 12. 重定向

​	响应行返回的状态码是301，状态301就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的Location字段中，接下来，浏览器获取Location字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。



## 13.构建DOM树

​	网络进程获取完数据后，将数据交给渲染进程处理。

​	由于浏览器无法直接理解和使用html，所以需要将HTML转换为浏览器能够理解的结构——DOM树。

1. **转换**： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。
2. **令牌化**： 浏览器将字符串转换成 [W3C HTML5 标准](https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fparsing.html)规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。
3. **词法分析**： 发出的令牌转换成定义其属性和规则的“对象”。
4. **DOM构建**： 由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系



## 14. 样式计算

### 1）把CSS转换为浏览器能够理解的结构

CSS样式的主要来源：

- 通过` link `引用的外部 CSS 文件
- `<style>`标签内的样式
- 元素的 `style` 属性内嵌的 CSS

​	浏览器无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会将CSS文本转换为浏览器可以理解的结构`styleSheets`, 该结构同时具备了查询和 修改功能。



### 2）转换样式表的属性，使其标准化

CSS文本中有很多属性值，如`em`、`blue`、`bold`，这些类型数值不容易被渲染引擎理解，所以需要将所有值转化为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100836062.png)



### 3）计算出DOM树中每个节点的具体样式

现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？

- **继承**： 每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫`UserAgent样式`。
- **层叠**： 定义了如何合并来自多个源的属性值的算法。

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100836529.png)

​	这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。



## 15. 布局定位

​	计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。

### 1）创建布局树

构建一棵只包含可见元素布局树。

1. 遍历DOM树中的所有可见节点，并把这些节点加入到布局中；
2. 而不可间的节点会被布局树忽略掉

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100837780.png)

### 2）布局计算

​	计算每个元素的几何坐标位置，并将这些信息保存在布局树中。



## 16. 图层分层

​	现在我们有了布局树，但依旧不能直接开始绘制。

​	因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果。渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

​	浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

​	并不是布局树的每个节点都能生成一个图层，如果一个节点没有自己的层，那么这个节点就从属于父节点的图层

​	通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

1. **拥有层叠上下文属性的元素会被提升为单独的一层**
   - HTML根元素本身就具有层叠上下文
   - 普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文。
   - 元素的 **opacity** 值不是 1
   - 元素的 **transform** 值不是 none
   - 元素的 **filter** 值不是 none
   - 元素的 **isolation** 值是isolate
   - **will-change**指定的属性值为上面任意一个。

2. **需要剪裁（clip）的地方也会被创建为图层**`overflow`



## 17. 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

1. 首先会把图层拆解成一个一个的绘制指令，排布成一个绘制列表

2. 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程

   ![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100839778.webp)

## 18. 分块

​	可能图层很大，页面内容很多，展示的只是视口内容，所以这种情况下，绘制全部图层内容的话，会产生较大开销。所以合成线程接下来会把图层划分为图块（tile）。



## 19. 光栅化

接着上面的步骤，有了图块之后，**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**

-  图块是栅格化执行的最小单位
-  渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**
-  合成线程会选择视口附近的**图块(tile)**，把它交给**栅格化线程池**生成位图
-  生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给`合成线程`

![img](https://cdn.jsdelivr.net/gh/option-star/imgs/202204100840764.webp)

## 20. 合成

​	一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

​	浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，然后把这部分内存发送给显卡。

​	屏幕每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传过来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**， 然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。
