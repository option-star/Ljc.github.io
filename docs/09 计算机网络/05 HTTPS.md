---
title: 计网05 HTTPS
date: 2021-11-09
sidebar: 'auto'
categories:
- 09计网
isShowComments: true
---

## 为什么需要HTTPS

::: tip

HTTP存在的问题

:::

### 1. 窃听风险

#### 原因

​	由于HTTP本身不具备加密功能，所以也没办法做到对通信进行加密所以只能使用明文方式发送。

#### 解决

​	**信息加密**：HTTP交互信息是被加密的，第三方就无法窃取；



### 2. 冒充风险

#### 原因

​		在HTTP协议通信时，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患：

1.   不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。
2.   无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
3.   无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限
4.   无法判定请求是来自何方、出自谁手。
5.    即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击).

#### 解决

​		**身份证书**：HTTP协议无法确定通信方但是SSL可以。SSL不仅提供加密处理，还提供一种被称为证书的东西，可用于确定方。证书是由CA机构颁发，用于证明服务器和客户端是真实存在的。伪造证书从技术角度来说是非常困难的，所以只要能够确认通信方所持有的证书即可判断通信方的真实意图。

### 3. 篡改风险

#### 原因

​	由于HTTP无法保证报文的真实性，因此，请求发送后直到对方接收之前的这段时间里，请求被修改了也无法获悉。遭攻击者拦截并篡改内容的攻击称为中间人攻击。

#### 解决

​	校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；



## 数字签名和数字证书

### 如何保证消息不被篡改

为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。

​	对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

​	那么，在计算机里会**用哈希函数来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171253701.png)

### 如何保证消息的来源可靠？

​	通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

计算机里会用**非对称加密算法**来解决，共有两个密钥：

- 一个是公钥，这个是可以公开给所有人的；
- 一个是私钥，这个必须由本人管理，不可泄露。

这两个密钥可以**双向加解密**的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。

流程的不同，意味着目的也不相同：

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。

​	所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171257586.png)

​	私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

### 如何保证对方的身份？

前面我们知道：

- 可以通过哈希算法来保证消息的完整性；
- 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

但是这还远远不够，**还缺少身份验证的环节**，万一公钥是被伪造的呢？

​	在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171301014.jpeg)



### 数字证书签发和验证流程

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171302951.png)

CA 签发证书的过程，如上图左边部分：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

### 证书链

​	但事实上，证书的验证过程中**还存在一个证书信任链的问题**，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171305474.png)

对于这种三级层级关系的证书的验证过程如下：

- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。
- 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。
- “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171306085.png)

操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171306914.png)

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcHRjNIVLnlm80E4IOk5JT2UWMP7uWTeiciczxm4OcXjRrMZpzMZaVkP8dwbOFGq0zUfGRrQ1uZWt1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

**这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。**



## 什么是HTTPS

![https](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081457057.jpeg)

HTTPS并不是一种新协议，只是HTTP通信接口部分使用SSL(`Secure Socket Layer`)或者TLS（`Transport LayerSecurity`）协议替代。

通常, HTTP直接和TCP通信。当使用SSL时，则HTTP先和SSL通信，再由SSL和TCP通信。简而言之，HTTPS就是身披SSL协议外壳的HTTP。

使用SSL后 ,HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

SSL是独立于HTTP的协议，所以在应用层的SMTP和Telnet等协议均可配合SSL协议使用

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081512824.webp)

## HTTPS做了什么

- `加密(Encryption)`， 通过对数据加密，防止数据被监听
- `数据一致性(Data integrity)`，确保数据在传输过程中不会被修改。
- `身份认证(Authentication)`，指确认对方的真实身份，防止中间人攻击并建立用户信任。

## HTTPS的加密方式

### 1. 共享密钥加密

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081632618.jpeg)

​		加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。以共享密钥方式加密时必须将密钥也发给对方,可究竟怎样才能安全地转交？

### 2. 公开密钥加密

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081634880.jpeg)

​		公开密钥加密的方式很好的解决了安全问题。公开密钥加密使用一对非对称的密钥。一把为私钥，一把为公钥，其中私钥是不能让任何人得知的，而公钥则可以随便公布。发送密文的一段，使用对方的公钥进行加密，对方接收到加密信息后，使用自己的私钥进行解密。这样就避免了发送解密的私钥，解决了对称密钥共享的安全问题。(公钥加密对称加密的密钥，私钥则进行解密)。

### 3. 混合密钥加密（HTTPS）

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081635407.jpeg)

​		HTTPS采用共享密钥加密和公开密钥加密的混合加密机制。在交换密钥环节，使用公开密钥加密技术，之后通信报文交换的阶段，则可以使用共享密钥加密技术。



## SSL/TLS

::: tip

[RFC文档](https://datatracker.ietf.org/doc/html/rfc5246)

:::

![TLS/SSL协议](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081716418.webp)

### SSL和TLS的关系

-   1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
-   1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
-   1996年，SSL 3.0版问世，得到大规模应用。
-   1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版[TLS](https://en.wikipedia.org/wiki/Secure_Sockets_Layer) 1.0版。
-   2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的[修订版](https://tools.ietf.org/html/rfc6176)。

### 基本运行过程

​		SSL/TLS协议的基本思路是采用[公钥加密法](https://en.wikipedia.org/wiki/Public-key_cryptography)，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

但是，这里有两个问题：

1.   如果保证公钥不被篡改？

解决方法：将公钥放在[数字证书](https://en.wikipedia.org/wiki/Digital_certificate)中。只要证书是可信的，公钥就是可信的。

2.   公钥加密计算量太大，如何减少耗用的时间？

解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

所以，SSL/TLS协议基本过程是这样的：

1.   客户端向服务器端索要并验证公钥。
2.   双方协商生成"对话密钥"。
3.   双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

### 握手阶段详细过程

![img](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081653280.png)

#### 1. 客户端发出请求（ClientHello）

​		首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。

请求内容：

-   支持的协议版本，比如TLS 1.0版。
-   一个客户端生成的随机数，稍后用于生成"对话密钥"。
-   支持的加密方法，比如RSA公钥加密。
-   支持的压缩方法。

#### 2.  服务器回应（SeverHello）

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。

响应内容：

-   确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
-   一个服务器生成的随机数，稍后用于生成"对话密钥"。
-    确认使用的加密方法，比如RSA公钥加密。
-   服务器证书。

#### 3. 客户端回应

​		客户端收到服务器回应后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

​		如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送响应。

响应内容：

-    一个随机数。该随机数（"pre-master key"）用服务器公钥加密，防止被窃听。
-   编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
-   客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

:::tip

整个握手阶段，客户端和服务器同时就有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，[dog250](http://blog.csdn.net/dog250/article/details/5717162)有解释：

解释：

​		"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

​		对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

​		pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

:::

#### 4. 服务器的最后回应

​		服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后向客户端响应。

响应信息：

-   编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
-   服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。



## RSA 握手

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171316464.png)

### 1. 第一次握手

​	客户端首先会发一个「**Client Hello**」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（\*Client Random\*）**，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。

> Client Hello

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171323648.png)



### 2. 第二次握手

1. 当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成**随机数（\*Server Random\*）**。
2. 接着，返回「**Server Hello**」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。

> Server Hello

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171324996.png)

3. 然后，服务端为了证明自己的身份，会发送「**Server Certificate**」给客户端，这个消息里含有数字证书。

> Server Certificate

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171326813.png)

4. 随后，服务端发了「**Server Hello Done**」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。

> Server Hello Done

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171327998.png)



### 3. 第三次握手

1. 客户端验证证书
2. 客户端就会生成一个新的**随机数 (\*pre-master\*)**，用服务器的 RSA 公钥加密该随机数，通过「**Change Cipher Key Exchange**」消息传给服务端。

> **Change Cipher Key Exchange**

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171329451.png)

3. 生成完会话密钥后，然后客户端发一个「**Change Cipher Spec**」，告诉服务端开始使用加密方式发送消息。

> Change Cipher Spec

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171332400.png)

4. 然后，客户端再发一个「**Encrypted Handshake Message（Finishd）**」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。

> Encrypted Handshake Message（Finishd）

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171333955.png)







### 4. 第四次握手

​	服务器也是同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

​	最后，就用「会话密钥」加解密 HTTP 请求和响应了。

### 5. RSA算法的缺陷

​	**使用 RSA 密钥协商算法的最大问题是不支持前向保密**。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

​	为了解决这一问题，于是就有了 DH 密钥协商算法，这里简单介绍它的工作流程。

![图片](https://gitee.com/ljcdzh/my_pic/raw/master/img/202203171335422.png)

客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。

DH 密钥交换过程中，**即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是实时生成的，实现前向保密**。

但因为 DH 算法的计算效率问题，后面出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。

## ECDHE 握手







## HTTPS的通信步骤

::: tip

有必要了解一下的故事：[用信鸽来解释 HTTPS](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485207&idx=1&sn=64827cd627ad08798d21076cef1b7cfa&chksm=ebd6383bdca1b12de54dc4e157543b2ff63fc8c876a73f830d3855760b90ae109b239ade633f&mpshare=1&scene=24&srcid=0416kj0u5u9OKS1MIT61ETQM#rd)

:::

![HTTPS加解密流程](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081526798.webp)



![过程](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111081503309.jpeg)

1.  客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2.  服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送Certificate报文。报文中包含公开密钥的证书（用于非对称加密）。
4.  最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。
5. SSL第一次握手结束之后，客户端以Client KeyExchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串（用于对称加密）。该报文已用步骤3中的公开密钥进行加密。
6.  接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。
7. 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送Change Cipher Spec报文。
9.  服务器同样发送Finished报文。
10.  服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。
11.  应用层协议通信，即发送HTTP响应
12. 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。



## HTTPS的缺点

​		与纯文本通信相比，加密通信**会消耗更多的CPU和内存资源**。如果每次通信都加密，会消耗相当多的资源。平摊到一台计算机上，能够处理的请求数量必定随之减少。因此，如果是非敏感信息则使用HTTP通信，只有包含个人信息等敏感数据时，才利用https加密通信。特别是每当那些访问量较多的web网站进行加密处理，它们所承担的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要隐藏的信息才会加密，以节约资源。 

## 参考

1. [图解HTTP](https://weread.qq.com/web/reader/3da32b505dd9f43da9a1acakd8232f00235d82c8d161fb2)
2. [看完这篇 HTTPS，和面试官扯皮就没问题了](https://juejin.cn/post/6844904089495535624)
3. [《大前端进阶 安全》系列 HTTPS详解（通俗易懂）](https://juejin.cn/post/6844904127420432391)
4. [分分钟让你理解HTTPS](https://juejin.cn/post/6844903599303032845)
4. [SSL/TLS协议运行机制的概述](SSL/TLS协议运行机制的概述)

