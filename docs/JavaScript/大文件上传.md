---
title: 大文件上传
date: 2021-11-16
sidebar: 'auto'
tags:
- js
categories:
- JavaScript
isShowComments: true
---



## 大文件上传的两种方式

![image-20211116145106776](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161451459.png)

- **FormData**：选择文件后，客户端通过ajax以FormData数据格式发送POST，服务器端接受到客户端传递的file等信息后，先在服务器端创建file文件，然后，把服务器存储的文件地址返回给客户端。
- **Base64**：选择文件后，客户端通过ajax请求将当前文件以Base64编码的格式传递给服务器 。服务器端接受到base64信息，把base64转换为具体的图片存储，返回存储图片的地址。



## 客户端部分

### 环境安装

1. 创建vite项目

```js
yarn create vite
```

2. 安装elementplus

```js
yarn add element-plus
```

> main.js

```js
import { createApp } from 'vue'
import App from './App.vue'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

createApp(App).use(ElementPlus).mount('#app')
```



### 上传控件

> vue.js

```js
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <el-button @click="handleUpload">上传</el-button>
  </div>
</template>
<script>
export default {
  data: () => ({
    container: {
      file: null,
    },
  }),
  methods: {
    /**
     * 选择文件
     */
    handleFileChange(e) {
      const [file] = e.target.files;
      if (!file) return;
      Object.assign(this.$data, this.$options.data());
      this.container.file = file;
      console.log(this.container.file);
    },

    /**
     * 用于上传
     */
    async handleUpload() {},
  },
};
</script>

```

![image-20211118100527156](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111181005402.png)

### 请求逻辑

```js
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <el-button @click="handleUpload">上传</el-button>
  </div>
</template>
<script>
export default {
  data: () => ({
    container: {
      file: null,
    },
  }),
  methods: {
    /**
     * 选择文件
     */
    handleFileChange(e) {
      const [file] = e.target.files;
      if (!file) return;
      Object.assign(this.$data, this.$options.data());
      this.container.file = file;
      console.log(this.container.file);
    },

    /**
     * 用于上传
     */
    async handleUpload() {},

    /**
     * 封装请求逻辑(新增)
     */
    request({ url, method = "post", data, headers = {}, requestList }) {
      return new Promise((resolve) => {
        const xhr = new XMLHttpRequest(); // 创建XML实例
        xhr.open(method, url); // 初始化请求
        Object.keys(headers).forEach((key) =>
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data); // 发送HTTP请求
        xhr.onload = (e) => { // 请求成功调用该函数
          resolve({
            data: e.target.response,
          });
        };
      });
    },
  },
};
</script>
```

### 上传切片

#### 补充

> Array.property.map

```js
arr.map(function callback(currentValue[, index[, array]]) {
 // Return element for new_array 
}[, thisArg])
```

- callback: 生成新数组元素的函数
- currentValue： callback数组中正在处理的当前元素
- index: 可选，数组中正在处理的当前元素的索引
- array： 可选，map方法调用的数组
- thiArg：可选，执行callback函数时值被用作this

> Promise.all

​		Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。

#### 思路

1. 选择好文件后，点击上传按钮会触发handleUpload函数
2. 它会先将选择好的文件通过crateFileChunk进行切片，然后用fileChunkList存储切片文件
3. 再为每个切片文件添加hash值
4. 最后通过调用uploadChunks，以上传所有切片
5. 在uploadChunks中，会先将切片文件转换为formdata形式，然后封装成promise请求模式，最后通过Promise.all方法进行并发切片。

#### 核心代码

> vue.js

```js
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <el-button @click="handleUpload">上传</el-button>
  </div>
</template>
<script>
+ const SIZE = 100 * 1024; // 切片大小
export default {
  data: () => ({
    container: {
      file: null,
    },
+    data: [], // 存放切片数据
  }),
  methods: {
    /**
     * 选择文件
     */
    handleFileChange(e) {
      const [file] = e.target.files;
      if (!file) return;
      Object.assign(this.$data, this.$options.data());
      this.container.file = file;
    },

    /**
     * 用于上传
     */
+    async handleUpload() {
      if (!this.container.file) return; // 若错
      const fileChunkList = this.crateFileChunk(this.container.file); // 根据文件生成文件切片
      this.data = fileChunkList.map(({ file }, index) => ({
        // 为每个切片添加hash值
        chunk: file,
        hash: this.container.file.name + "-" + index, // 文件名 + 数组下标
      }));
      await this.uploadChunks(); // 上传切片
    },

    /**
     * 封装请求逻辑
     */
    request({ url, method = "post", data, headers = {}, requestList }) {
      return new Promise((resolve) => {
        const xhr = new XMLHttpRequest(); // 创建XML实例
        xhr.open(method, url); // 初始化请求
        Object.keys(headers).forEach((key) =>
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data); // 发送HTTP请求
        xhr.onload = (e) => {
          // 请求成功调用该函数
          resolve({
            data: e.target.response,
          });
        };
      });
    },

    /**
     * 用于生成文件切片
     * @param {*} file 需切片的文件
     * @param {number} size 切片的大小
     * @return
     */
+    crateFileChunk(file, size = SIZE) {
      const fileChunkList = [];
      let cur = 0;
      while (cur < file.size) {
        fileChunkList.push({ file: file.slice(cur, cur + size) });
        cur += size;
      }
      return fileChunkList;
    },

    /**
     * 上传切片
     */
+    async uploadChunks() {
      const requestList = this.data // 获取切片数据
        .map(({ chunk, hash }) => { // 将每个切片转化为formData形式
          const formData = new FormData();
          formData.append("chunk", chunk);
          formData.append("hash", hash);
          formData.append("filename", this.container.file.name);
          return { formData };
        })
        .map(async ({ formData }) => // 将每个切片转化为promise请求实例
          this.request({
            url: "http://localhost:9527",
            data: formData,
          })
        );
      await Promise.all(requestList); // 并发切片
    },
  },
};
</script>
```

#### 效果展示

> 切片效果

![image-20211118103227138](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111181032347.png)

> 添加hash效果

![image-20211120094505244](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111200945393.png)





### 发送合并请求

#### 思路

1. 通过调用uploadChunks()上传完切片后
2. 然后调用mergeRequest()方法，发送合并请求，请求的data内容为文件名称做标识



#### 核心代码

```js
<template>
  <div>
    <input type="file" @change="handleFileChange" />
    <el-button @click="handleUpload">上传</el-button>
  </div>
</template>
<script>
const SIZE = 100 * 1024; // 切片大小
export default {
  data: () => ({
    container: {
      file: null,
    },
    data: [], // 存放切片数据
  }),
  methods: {
    /**
     * 选择文件
     */
    handleFileChange(e) {
      const [file] = e.target.files;
      if (!file) return;
      Object.assign(this.$data, this.$options.data());
      this.container.file = file;
    },

    /**
     * 用于上传
     */
    async handleUpload() {
      if (!this.container.file) return; // 若错
      const fileChunkList = this.crateFileChunk(this.container.file); // 根据文件生成文件切片
      this.data = fileChunkList.map(({ file }, index) => ({
        // 为每个切片添加hash值
        chunk: file,
        hash: this.container.file.name + "-" + index, // 文件名 + 数组下标
      }));
      await this.uploadChunks(); // 上传切片

+      await this.mergeRequest(); // 发送合并请求
    },

    /**
     * 封装请求逻辑
     */
    request({ url, method = "post", data, headers = {}, requestList }) {
      return new Promise((resolve) => {
        const xhr = new XMLHttpRequest(); // 创建XML实例
        xhr.open(method, url); // 初始化请求
        Object.keys(headers).forEach((key) =>
          xhr.setRequestHeader(key, headers[key])
        );
        xhr.send(data); // 发送HTTP请求
        xhr.onload = (e) => {
          // 请求成功调用该函数
          resolve({
            data: e.target.response,
          });
        };
      });
    },

    /**
     * 用于生成文件切片
     * @param {*} file 需切片的文件
     * @param {number} size 切片的大小
     * @return
     */
    crateFileChunk(file, size = SIZE) {
      const fileChunkList = [];
      let cur = 0;
      while (cur < file.size) {
        fileChunkList.push({ file: file.slice(cur, cur + size) });
        cur += size;
      }
      return fileChunkList;
    },

    /**
     * 上传切片
     */
    async uploadChunks() {
      const requestList = this.data // 获取切片数据
        .map(({ chunk, hash }) => {
          // 将每个切片转化为formData形式
          const formData = new FormData();
          formData.append("chunk", chunk);
          formData.append("hash", hash);
          formData.append("filename", this.container.file.name);
          return { formData };
        })
        .map(
          async (
            { formData } // 将每个切片转化为promise请求实例
          ) =>
            this.request({
              url: "http://localhost:9527",
              data: formData,
            })
        );
      await Promise.all(requestList); // 并发切片
    },

    /**
     * 用于发送合并请求
     */
+    async mergeRequest() {
      await this.request({
        url: "http://localhost:9527/merge",
        headers: {
          "content-type": "application/json",
        },
        data: JSON.stringify({
          filename: this.container.file.name,
        }),
      });
    },
  },
};
</script>
```





## 服务端部分



### 1. 搭建http模块服务端

#### 核心代码

```js
const http = require("http");
const server = http.createServer();

server.on("request", async (req, res) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "*");
  if (req.method === "OPTIONS") {
    res.status = 200;
    res.end();
    return;
  }
});

server.listen(9527, () => console.log("正在监听 9527 端口"));

```

#### 效果展示

```js
const http = require("http");
const server = http.createServer();

server.on("request", async (req, res) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "*");
  if (req.method === "OPTIONS") {
    res.status = 200;
    res.end();
    return;
  }
});

server.listen(9527, () => console.log("正在监听 9527 端口"));
```

### 2. 接受切片

#### 环境配置

```js
yarn add fs-extra 

yarn add multiparty
```



#### 补充

> path.resolve

​	path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve('/foo', '/bar', 'baz') 会返回 /bar/baz。



#### 思路

1. 使用`multiparty`包处理前端传来的FormData
2. 在multipartty.parse的回调中
    1. files参数保存了FormData中文件
    2. fields参数保存了FormData中非文件的字段
3. 当前端发来formData的请求时， 通过multiparty包对其处理
4. 通过获取解析后的结果，先用传来文件名来创建目录。
5. 再将切片文件从临时保存的位置移动到，自己生成的目录中，其切片文件名即为当前切片文件的hash值。



#### 核心代码

```js
const http = require("http");
const path = require("path");
const fse = require("fs-extra"); // 文件处理
const multiparty = require("multiparty");

const server = http.createServer();

/* 大文件存储目录 */
const UPLOAD_DIR = path.resolve(__dirname, "..", "target");

server.on("request", async (req, res) => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");
    if (req.method === "OPTIONS") {
        res.status = 200;
        res.end();
        return;
    }

    const multipart = new multiparty.Form(); // 创建表单

    /* 对请求中的formData数据进行处理 */
    multipart.parse(req, async (err, fields, files) => {
        if (err) {
            return;
        }
        console.log(fields, files)
        const [chunk] = files.chunk;
        const [hash] = fields.hash;
        const [filename] = fields.filename;
        const chunkDir = path.resolve(UPLOAD_DIR, filename); // 根据文件名创建绝对路径

        // 切片目录不存在，创建切片文件夹
        if (!fse.existsSync(chunkDir)) {
            await fse.mkdirs(chunkDir);
        }

        // chunk.path : 存储临时文件的路径
        await fse.move(chunk.path, `${chunkDir}/${hash}`); // 将切片文件从临时保存的位置移动到自己生成的目录中
        res.end("收到文件块");
    });
});

server.listen(9527, () => console.log("正在监听 9527 端口"));
```



### 3. 合并切片

#### 	思路

1. 通过给当前切片文件创建可读流，为需要写入的文件创建可写流
2. 通过管道操作pipe，先通过可写流读取目标的文件，然后写入目标文件中。



#### 核心代码

> server/index.js

```js
const http = require("http");
const path = require("path");
const fse = require("fs-extra"); // 文件处理
const multiparty = require("multiparty");

const server = http.createServer();

/* 大文件存储目录 */
const UPLOAD_DIR = path.resolve(__dirname, "..", "target");

/**
 * 对请求进行处理
 * @param {*} req 合并请求
 * @returns 
 */
const resolvePost = req =>
    new Promise(resolve => {
        let chunk = "";
        req.on("data", data => {
            chunk += data;
        });
        req.on("end", () => {
            resolve(JSON.parse(chunk));
        });
    });

/**
 * 通过管道操作，进行文件的写入
 * @param {*} path 切片文件名称
 * @param {*} writeStream 可写流
 * @returns 
 */
const pipeStream = (path, writeStream) =>
    new Promise(resolve => {
        const readStream = fse.createReadStream(path); // 创建可读流
        readStream.on("end", () => {
            fse.unlinkSync(path);
            resolve();
        });
        readStream.pipe(writeStream);
    });


/**
 * 合并切片
 * @param {*} filePath 文件路径
 * @param {*} filename 文件名称
 * @param {*} size  文件大小
 */
const mergeFileChunk = async (filePath, filename, size) => {
    const chunkDir = path.resolve(UPLOAD_DIR, filename); // 获取要合并的文件路径
    const chunkPaths = await fse.readdir(chunkDir); // 获取所有切片文件路径

    /* 根据切片下标进行排序， 否则直接读取目录的获得的顺序可能会错乱 */
    chunkPaths.sort((a, b) => a.split("-")[1] - b.split("-")[1]);


    await Promise.all( // 通过流的方式按顺序写入同一个文件进行文件的合并
        chunkPaths.map((chunkPath, index) =>
            pipeStream(
                path.resolve(chunkDir, chunkPath), // 传入切片文件的绝对路径
                fse.createWriteStream(filePath, { // 根据文件路径创建可写流
                    start: index * size,
                    end: (index + 1) * size
                })
            )
        )
    );
    fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录
};

server.on("request", async (req, res) => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");
    if (req.method === "OPTIONS") {
        res.status = 200;
        res.end();
        return;
    }

    /* 合并切片请求 */
    if (req.url === "/merge") {
        const data = await resolvePost(req);
        const { filename, size } = data;
        const filePath = path.resolve(UPLOAD_DIR, `${filename}`);
        await mergeFileChunk(filePath, filename);
        res.end(
            JSON.stringify({
                code: 0,
                message: "文件合并成功"
            })
        );
    }

    const multipart = new multiparty.Form(); // 创建表单

    /* 对请求中的formData数据进行处理 */
    multipart.parse(req, async (err, fields, files) => {
        if (err) {
            return;
        }
        console.log(fields, files)
        const [chunk] = files.chunk;
        const [hash] = fields.hash;
        const [filename] = fields.filename;
        const chunkDir = path.resolve(UPLOAD_DIR, filename); // 根据文件名创建绝对路径

        // 切片目录不存在，创建切片文件夹
        if (!fse.existsSync(chunkDir)) {
            await fse.mkdirs(chunkDir);
        }

        // chunk.path : 存储临时文件的路径
        await fse.move(chunk.path, `${chunkDir}/${hash}`); // 将切片文件从临时保存的位置移动到自己生成的目录中
        res.end("收到文件块");
    });
});

server.listen(9527, () => console.log("正在监听 9527 端口"));
```

> App.vue

```js
    /**
     * 用于发送合并请求
     */
    async mergeRequest() {
      await this.request({
        url: "http://localhost:9527/merge",
        headers: {
          "content-type": "application/json",
        },
        data: JSON.stringify({
          size: SIZE,
          filename: this.container.file.name,
        }),
      });
    }
```

