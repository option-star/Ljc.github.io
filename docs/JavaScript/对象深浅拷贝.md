---
title: 深浅拷贝
date: 2021-11-16
sidebar: 'auto'
tags:
- js
categories:
- JavaScript
isShowComments: true
---



:::tip

```js
// 需克隆的对象
let obj = {
    url: '/api/list',
    method: 'GET',
    cache: false,
    timeout: 1000,
    key: Symbol('KEY'),
    big: 10n,
    n: null,
    u: undefined,
    headers: {
        'Content-Type': 'application/json',
        post: {
            'X-Token': 'xxx'
        }
    },
    arr: [10, 20, 30],
    reg: /^\d+$/,
    time: new Date(),
    fn: function () {
        console.log(this);
    },
    err: new Error('xxx')
};
obj.obj = obj;
```

:::

## 浅克隆

:::tip

​	浅克隆：克隆的目标对象若嵌套着引用类型的值，浅克隆并不会开辟新的堆空间存储嵌套的值，而是直接指向原本的堆空间。

:::

### 1. [Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

```js
let new_obj = Object.assign({}, obj);
```

![image-20211116103531981](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161035087.png)

### 2. 展开运算符

```js
let new_obj = {
    ...obj
}
```

![image-20211116103920266](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161039310.png)

### 3. 循环

```js
let new_obj = {};
for(key in obj) {
    new_obj[key] = obj[key];
}
```

![image-20211116105059472](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161050530.png)



## 深克隆

### 1. [JSON.stringify](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)/[parse](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)

- JSON.stringify：把对象／数组变成JSON字符串
- JSON.parse ：把JSON字符串变为对象/数组。【浏览器需要重新开辟所有内存】

**代码**：

```js
let obj = {
    url: '/api/list',
    method: 'GET',
    cache: false,
    big: 10n,
    headers: {
        'Content-Type': 'application/json',
        post: {
            'X-Token': 'xxx'
        }
    }
};
let newObj = JSON.parse(JSON.stringify(obj));
console.log(newObj === obj);
console.log(newObj.headers === obj.headers)
```

**实例**：

![image-20211116112545732](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161125777.png)

**缺点**：

1. 不允许出现套娃操作

![image-20211116112754333](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161127372.png)

2. 属性值不能是BigInt

![image-20211116112937245](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161129287.png)

3. 丢失一些内容：只要属性值为 symbol/undefined/function 这些类型的

    ![image-20211116113311435](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161133487.png)

4. 还有信息不准确的，例如：正则->空对象  Error对象->空对象  日期对象->字符串  ...

![image-20211116113311435](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161135738.png)

### 2. Qs.stringify/parse

**导入**

```js
// 导入qs
npm i qs
```

**实例**

![image-20211116114655736](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161146798.png)

![image-20211116114716871](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111161147913.png)

**缺点**：

1. 不允许出现套娃操作，否则会死循环
2. function类型数据会丢失

### 3. 手写实现

```js
// 实现数组和对象深/浅拷贝
var clone = function clone() {
    var target = arguments[0],
        deep = false,
        type,
        isArray,
        isObject,
        result,
        Ctor,
        treated = arguments[arguments.length - 1];
    !Array.isArray(treated) || !treated.treated ? (treated = [], treated.treated = true) : null;
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1];
    }

    // 防止死递归的处理
    if (treated.indexOf(target) > -1) return target;
    treated.push(target);

    // 校验类型
    type = toType(target);
    isArray = Array.isArray(target);
    isObject = isPlainObject(target);

    // 特殊值的拷贝
    if (target == null) return target;
    Ctor = target.constructor;
    if (/^(regexp|date)$/i.test(type)) return new Ctor(target);
    if (/^(error)$/i.test(type)) return new Ctor(target.message);
    if (/^(function|generatorfunction)$/i.test(type)) {
        return function proxy() {
            var args = Array.from(arguments);
            return target.apply(this, args);
        };
    }
    if (!isArray && !isObject) return target;

    // 如果是数组/对象，我们依次迭代赋值给新的数组/对象
    result = new Ctor();
    each(target, function (copy, name) {
        if (deep) {
            // 深拷贝
            result[name] = clone(deep, copy, treated);
            return;
        }
        // 浅拷贝
        result[name] = copy;
    });
    return result;
};
```

