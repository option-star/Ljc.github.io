---
title:  数据类型判断
date: 2021-11-10
sidebar: 'auto'
tags:
- 数据类型
categories:
- JavaScript
isShowComments: true 
---



## 1. typeof

### 1.1 缺点

1.   不能检测null，结果为Object
2.   除可调用对象外，会返回function， 但是不能细分函数类型，其余对象数据值返回的都是object
3.   检测一个未被声明的变量不会报错，返回undefined

### 1.2 原理

​		typeof内部会调用GetValue（val）[C++内部提供的方法]，根据计算机底层存储的“二进制值”来检测的。

-   对象：000 -> 函数实现call，则返回‘function’,没有实现call返回‘object’
-   null：000000
-   undefined： -2^30
-   数字： 整数1，浮点是010
-   字符串：100
-   布尔：110

## 2. instanceof

### 2.1 简介

​	instanceof可以正确判断对象的类型，其内部运行机制是**判断在其原型链中能否找到该类型的原型**。

```js
console.log(2 instanceof Number);  // false
console.log(true instanceof Boolean); // false 
console.log('str' instanceof String);  // false 
console.log([] instanceof Array);  // true
console.log(function(){} instanceof Function);  // true
console.log({} instanceof Object);   // true
```

​		instanceof**只能正确判断引用数据类型，而不能判断基本数据类型**。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

### 2.2 手写instanceof

```js
function myInstanceof(left, right) {  // 获取对象的原型  
    let proto = Object.getPrototypeOf(left)  // 获取构造函数的 prototype 对象  
    let prototype = right.prototype;    // 判断构造函数的 prototype 对象是否在对象的原型链上 
    while (true) {    
        if (!proto) return false;    
        if (proto === prototype) return true;    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型   
        proto = Object.getPrototypeOf(proto);  
    }
}
```

## 3. constructor

### 3.1 作用

-   判断数据类型
-   对象实例通过`constrcutor`对象访问它的构造函数

### 3.2 实例

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```

### 3.3 缺点

-   如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了。

```js
function Fn(){}; 
Fn.prototype = new Array(); 
var f = new Fn(); 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true
```

## 4. `Object.prototype.toString.call([value])`

![image-20211110205032427](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111102050818.png)

问：同样是通过对象obj调用`tostring`方法，`obj.toString()`的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？

答：

​	这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都**重写了toString方法**。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。

