<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue01 基础 | 佳成</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.jfif">
    <meta name="description" content="生命太短，没有时间留给遗憾，若不是终点，请微笑一直向前。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a43a5fd5.css" as="style"><link rel="preload" href="/blog/assets/js/app.ce36d364.js" as="script"><link rel="preload" href="/blog/assets/js/3.69e5ab97.js" as="script"><link rel="preload" href="/blog/assets/js/1.d241725f.js" as="script"><link rel="preload" href="/blog/assets/js/32.86fb3e55.js" as="script"><link rel="preload" href="/blog/assets/js/8.a8350c27.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.09f36fdc.js"><link rel="prefetch" href="/blog/assets/js/100.9a4567d0.js"><link rel="prefetch" href="/blog/assets/js/101.3c662e09.js"><link rel="prefetch" href="/blog/assets/js/102.2b9a34c5.js"><link rel="prefetch" href="/blog/assets/js/103.32fa7ad2.js"><link rel="prefetch" href="/blog/assets/js/104.c286fafc.js"><link rel="prefetch" href="/blog/assets/js/105.c8ddb9c1.js"><link rel="prefetch" href="/blog/assets/js/106.2b785458.js"><link rel="prefetch" href="/blog/assets/js/107.8b77f252.js"><link rel="prefetch" href="/blog/assets/js/108.f50a5f5a.js"><link rel="prefetch" href="/blog/assets/js/109.103bcef3.js"><link rel="prefetch" href="/blog/assets/js/11.7793fe98.js"><link rel="prefetch" href="/blog/assets/js/110.0d5acd40.js"><link rel="prefetch" href="/blog/assets/js/111.5336593d.js"><link rel="prefetch" href="/blog/assets/js/112.a33ab9b5.js"><link rel="prefetch" href="/blog/assets/js/12.d80d454e.js"><link rel="prefetch" href="/blog/assets/js/13.4faf6f3c.js"><link rel="prefetch" href="/blog/assets/js/14.01c9bbf3.js"><link rel="prefetch" href="/blog/assets/js/15.094dd376.js"><link rel="prefetch" href="/blog/assets/js/16.29d9afb6.js"><link rel="prefetch" href="/blog/assets/js/17.51c765dd.js"><link rel="prefetch" href="/blog/assets/js/18.07be4755.js"><link rel="prefetch" href="/blog/assets/js/19.dc3f3f5a.js"><link rel="prefetch" href="/blog/assets/js/20.a3fdceac.js"><link rel="prefetch" href="/blog/assets/js/21.c656cbd0.js"><link rel="prefetch" href="/blog/assets/js/22.1da9d308.js"><link rel="prefetch" href="/blog/assets/js/23.8d3cf1f8.js"><link rel="prefetch" href="/blog/assets/js/24.fce2db27.js"><link rel="prefetch" href="/blog/assets/js/25.bcb92306.js"><link rel="prefetch" href="/blog/assets/js/26.1c678f57.js"><link rel="prefetch" href="/blog/assets/js/27.2103bdcb.js"><link rel="prefetch" href="/blog/assets/js/28.0dbf1553.js"><link rel="prefetch" href="/blog/assets/js/29.a11b760e.js"><link rel="prefetch" href="/blog/assets/js/30.ff3fe4d4.js"><link rel="prefetch" href="/blog/assets/js/31.ab568cb1.js"><link rel="prefetch" href="/blog/assets/js/33.42f05f15.js"><link rel="prefetch" href="/blog/assets/js/34.b4a829e6.js"><link rel="prefetch" href="/blog/assets/js/35.80c0fdeb.js"><link rel="prefetch" href="/blog/assets/js/36.a85c7b9f.js"><link rel="prefetch" href="/blog/assets/js/37.939e919b.js"><link rel="prefetch" href="/blog/assets/js/38.6ae284df.js"><link rel="prefetch" href="/blog/assets/js/39.ae4ac49c.js"><link rel="prefetch" href="/blog/assets/js/4.a9aaef9b.js"><link rel="prefetch" href="/blog/assets/js/40.54b3cd04.js"><link rel="prefetch" href="/blog/assets/js/41.e6bb513c.js"><link rel="prefetch" href="/blog/assets/js/42.50a0c76f.js"><link rel="prefetch" href="/blog/assets/js/43.e8f7ad54.js"><link rel="prefetch" href="/blog/assets/js/44.9b0a4783.js"><link rel="prefetch" href="/blog/assets/js/45.071066a7.js"><link rel="prefetch" href="/blog/assets/js/46.3ee56909.js"><link rel="prefetch" href="/blog/assets/js/47.a9221212.js"><link rel="prefetch" href="/blog/assets/js/48.bfa52697.js"><link rel="prefetch" href="/blog/assets/js/49.848371ed.js"><link rel="prefetch" href="/blog/assets/js/5.6825e976.js"><link rel="prefetch" href="/blog/assets/js/50.864591b1.js"><link rel="prefetch" href="/blog/assets/js/51.c14320a9.js"><link rel="prefetch" href="/blog/assets/js/52.432865c4.js"><link rel="prefetch" href="/blog/assets/js/53.d6923aa6.js"><link rel="prefetch" href="/blog/assets/js/54.3e644e3f.js"><link rel="prefetch" href="/blog/assets/js/55.13ac7014.js"><link rel="prefetch" href="/blog/assets/js/56.3e388e2c.js"><link rel="prefetch" href="/blog/assets/js/57.df4c79cd.js"><link rel="prefetch" href="/blog/assets/js/58.4bef1161.js"><link rel="prefetch" href="/blog/assets/js/59.70613c35.js"><link rel="prefetch" href="/blog/assets/js/6.6b1d65b3.js"><link rel="prefetch" href="/blog/assets/js/60.3150ed3e.js"><link rel="prefetch" href="/blog/assets/js/61.2f67d44b.js"><link rel="prefetch" href="/blog/assets/js/62.d67a1126.js"><link rel="prefetch" href="/blog/assets/js/63.a3ff419d.js"><link rel="prefetch" href="/blog/assets/js/64.5036d8de.js"><link rel="prefetch" href="/blog/assets/js/65.99a6a694.js"><link rel="prefetch" href="/blog/assets/js/66.1426e9b4.js"><link rel="prefetch" href="/blog/assets/js/67.fcf05bf1.js"><link rel="prefetch" href="/blog/assets/js/68.e39132b1.js"><link rel="prefetch" href="/blog/assets/js/69.2e4c6799.js"><link rel="prefetch" href="/blog/assets/js/7.bfc5f1ad.js"><link rel="prefetch" href="/blog/assets/js/70.1c901c73.js"><link rel="prefetch" href="/blog/assets/js/71.8d7d588b.js"><link rel="prefetch" href="/blog/assets/js/72.ee6ba0fb.js"><link rel="prefetch" href="/blog/assets/js/73.7282c958.js"><link rel="prefetch" href="/blog/assets/js/74.a0821211.js"><link rel="prefetch" href="/blog/assets/js/75.c2a3baa5.js"><link rel="prefetch" href="/blog/assets/js/76.5fd0f222.js"><link rel="prefetch" href="/blog/assets/js/77.4f7ff38c.js"><link rel="prefetch" href="/blog/assets/js/78.c0d1ba72.js"><link rel="prefetch" href="/blog/assets/js/79.ed013c37.js"><link rel="prefetch" href="/blog/assets/js/80.e8848415.js"><link rel="prefetch" href="/blog/assets/js/81.d57b0f9b.js"><link rel="prefetch" href="/blog/assets/js/82.75b64303.js"><link rel="prefetch" href="/blog/assets/js/83.c33330f2.js"><link rel="prefetch" href="/blog/assets/js/84.3167f244.js"><link rel="prefetch" href="/blog/assets/js/85.73e92e46.js"><link rel="prefetch" href="/blog/assets/js/86.dd646a22.js"><link rel="prefetch" href="/blog/assets/js/87.7c480915.js"><link rel="prefetch" href="/blog/assets/js/88.c119d757.js"><link rel="prefetch" href="/blog/assets/js/89.400af58e.js"><link rel="prefetch" href="/blog/assets/js/9.522cbdce.js"><link rel="prefetch" href="/blog/assets/js/90.7bd11d4e.js"><link rel="prefetch" href="/blog/assets/js/91.3bc4f2d7.js"><link rel="prefetch" href="/blog/assets/js/92.60d1591e.js"><link rel="prefetch" href="/blog/assets/js/93.dc12917a.js"><link rel="prefetch" href="/blog/assets/js/94.216bf33b.js"><link rel="prefetch" href="/blog/assets/js/95.5199ac5f.js"><link rel="prefetch" href="/blog/assets/js/96.4691ee55.js"><link rel="prefetch" href="/blog/assets/js/97.ccd76182.js"><link rel="prefetch" href="/blog/assets/js/98.2de14a26.js"><link rel="prefetch" href="/blog/assets/js/99.672fd77f.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a43a5fd5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>佳成</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>生命太短，没有时间留给遗憾，若不是终点，请微笑一直向前。</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>佳成</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.jfif" alt="佳成" class="logo"> <span class="site-name">佳成</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      技术
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/01HTML/" class="nav-link"><i class="undefined"></i>
  01HTML
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/02CSS/" class="nav-link"><i class="undefined"></i>
  02CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/03JavaScript/" class="nav-link"><i class="undefined"></i>
  03JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/04Vue/" class="nav-link"><i class="undefined"></i>
  04Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/05工程化/" class="nav-link"><i class="undefined"></i>
  05工程化
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/06手撕/" class="nav-link"><i class="undefined"></i>
  06手撕
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/07代码输出/" class="nav-link"><i class="undefined"></i>
  07代码输出
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/08性能/" class="nav-link"><i class="undefined"></i>
  08性能
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/09计网/" class="nav-link"><i class="undefined"></i>
  09计网
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/10浏览器/" class="nav-link"><i class="undefined"></i>
  10浏览器
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/11安全/" class="nav-link"><i class="undefined"></i>
  11安全
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/12常见业务/" class="nav-link"><i class="undefined"></i>
  12常见业务
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/13React/" class="nav-link"><i class="undefined"></i>
  13React
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/16Node/" class="nav-link"><i class="undefined"></i>
  16Node
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/17TypeScript/" class="nav-link"><i class="undefined"></i>
  17TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/19面经/" class="nav-link"><i class="undefined"></i>
  19面经
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/20设计模式/" class="nav-link"><i class="undefined"></i>
  20设计模式
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://github.com/option-star" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/blog/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    佳成
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>99</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>0</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      技术
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/01HTML/" class="nav-link"><i class="undefined"></i>
  01HTML
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/02CSS/" class="nav-link"><i class="undefined"></i>
  02CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/03JavaScript/" class="nav-link"><i class="undefined"></i>
  03JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/04Vue/" class="nav-link"><i class="undefined"></i>
  04Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/05工程化/" class="nav-link"><i class="undefined"></i>
  05工程化
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/06手撕/" class="nav-link"><i class="undefined"></i>
  06手撕
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/07代码输出/" class="nav-link"><i class="undefined"></i>
  07代码输出
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/08性能/" class="nav-link"><i class="undefined"></i>
  08性能
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/09计网/" class="nav-link"><i class="undefined"></i>
  09计网
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/10浏览器/" class="nav-link"><i class="undefined"></i>
  10浏览器
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/11安全/" class="nav-link"><i class="undefined"></i>
  11安全
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/12常见业务/" class="nav-link"><i class="undefined"></i>
  12常见业务
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/13React/" class="nav-link"><i class="undefined"></i>
  13React
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/16Node/" class="nav-link"><i class="undefined"></i>
  16Node
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/17TypeScript/" class="nav-link"><i class="undefined"></i>
  17TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/19面经/" class="nav-link"><i class="undefined"></i>
  19面经
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/20设计模式/" class="nav-link"><i class="undefined"></i>
  20设计模式
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://github.com/option-star" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>04 Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/docs/04-vue/01-vueji-chu.html" aria-current="page" class="active sidebar-link">Vue01 基础</a></li><li><a href="/blog/docs/04-vue/02-sheng-ming-zhou-qi.html" class="sidebar-link">Vue02 生命周期</a></li><li><a href="/blog/docs/04-vue/03-zu-jian-hua.html" class="sidebar-link">Vue03 组件化</a></li><li><a href="/blog/docs/04-vue/04-lu-you.html" class="sidebar-link">Vue04 路由</a></li><li><a href="/blog/docs/04-vue/05-vuex.html" class="sidebar-link">Vue05 Vuex</a></li><li><a href="/blog/docs/04-vue/06-vue3.0.html" class="sidebar-link">Vue06 Vue3.0</a></li><li><a href="/blog/docs/04-vue/07-xu-ni-dom.html" class="sidebar-link">Vue07 虚拟DOM</a></li><li><a href="/blog/docs/04-vue/08-shu-ju-qu-dong.html" class="sidebar-link">Vue08 数据驱动</a></li><li><a href="/blog/docs/04-vue/vue2he-xin-yuan-ma.html" class="sidebar-link">vue2核心源码</a></li><li><a href="/blog/docs/04-vue/vue3he-xin-yuan-ma.html" class="sidebar-link">Vue3核心源码</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Vue01 基础</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>佳成</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">Vue01 基础</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>佳成</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2022/3/21</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="_1-vue的基本原理"><a href="#_1-vue的基本原理" class="header-anchor">#</a> 1. Vue的基本原理</h2> <p>​	当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p> <p><img src="https://gitee.com/ljcdzh/my_pic/raw/master/img/202203202252848.webp" alt="0_tB3MJCzh_cB6i3mS-1.png"></p> <h2 id="_2-双向数据绑定的原理"><a href="#_2-双向数据绑定的原理" class="header-anchor">#</a> 2. 双向数据绑定的原理</h2> <p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p> <ol><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li> <li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li> <li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li> <li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol> <p><img src="https://gitee.com/ljcdzh/my_pic/raw/master/img/202203202253821.webp" alt="img"></p> <h2 id="_3-data什么情况是对象-函数"><a href="#_3-data什么情况是对象-函数" class="header-anchor">#</a> 3. data什么情况是对象？函数？</h2> <ul><li>在根组件中，data不会被共享，可以放对象也可以放函数</li> <li>在子组件中，data只能是一个函数，防止多个组件中共享一个数据</li></ul> <h2 id="_4-vue的初始化流程"><a href="#_4-vue的初始化流程" class="header-anchor">#</a> 4. vue的初始化流程</h2> <ol><li>new Vue时，传入options参数，并进行初始化操作_init</li> <li>该初始化函数_init在initMixin中定义，主要为了<code>_init</code>方法传递Vue构造函数，并在原型上挂载<code>_init</code>方法</li> <li>在<code>_init</code>方法中进行初始化
<ul><li>initState： 主要处理props、methods、data、computed、watch等对象</li> <li>….</li></ul></li> <li>最后，在<code>_init</code>方法中判断有无传入el参数，如果传入则将数据挂载到页面上。</li></ol> <h2 id="_5-vue中如何处理传入的data数据"><a href="#_5-vue中如何处理传入的data数据" class="header-anchor">#</a> 5. Vue中如何处理传入的data数据</h2> <div class="custom-block tip"><p class="title"></p><p>​	由于在初始化函数<code>_init</code>方法中，调用initState处理props、methods、data、computed、watch等数据，对于data通过<code>initData</code>的方法对数据进行处理</p></div><p><code>initData</code>函数的处理：</p> <ol><li>如果传入的是一个函数，则让函数的this指向Vue实例，并将函数返回值作为对象；如果传入的是一个对象，则直接使用对象。</li> <li><strong>数据代理</strong> ：通过proxy的方法进行代理data数据，即<code>vm.name = vm._data.name</code>，实际还是通过<code>Object.defineProperty</code>方法进行劫持</li> <li>通过observe方法，重写 data对象的所有属性，将data变成响应式。</li></ol> <h2 id="_6-如何将传入的data变成响应式"><a href="#_6-如何将传入的data变成响应式" class="header-anchor">#</a> 6. 如何将传入的data变成响应式？</h2> <div class="custom-block tip"><p class="title"></p><ol><li>new Vue会调用_init方法进行初始化</li> <li>会将用户的选项放到vm.$options上</li> <li>会对当前属性上搜索有没有data数据 (initState)</li> <li>有data判断data是不是一个函数，如果是函数取返回值 (initData)</li> <li>observe 去观测data中的对象</li> <li>如果更新对象不存在的属性，会导致视图不更新，如果是数组更新索引和长度不会触发更新。</li> <li>如果是替换成一个新对象，新对象会被进行劫持，如果是数组存放新内容 push unshift（）新增的内容也会被劫持</li> <li>通过<code>__ob__</code>进行标识这个对象被监控过。</li></ol></div><p>​	Vue中主要通过observe方法对data中数据进行观测：</p> <ol><li>先判断传入的是否是对象， 如果不是对象，则直接return，不做观测</li> <li>通过Observe类来对data进行处理，如果观测过就跳过观测</li></ol> <h2 id="_7-vue中如何识别被观测过的数据"><a href="#_7-vue中如何识别被观测过的数据" class="header-anchor">#</a> 7. Vue中如何识别被观测过的数据？</h2> <p>​	如果一个数据已经被观测过了，就不要观测了，用Observe类来实现，我观测过就增加一个标识<code>__ob_</code>，说明观测过了，在观测的时候，可以先检测是否观测过，如果观测过就跳过检测。</p> <p>Observe类具体实现：</p> <ol><li>在data上添加<code>__ob__</code>属性，为Observe类的实例，所有被劫持过的属性都有<code>__ob__</code></li> <li>如果传入的值是对象， 通过调用<code>walk</code>方法，循环遍历对象，通过<code>defineReactive</code>方法重新定义属性, 进行数据劫持</li> <li>如果传入的值是数组
<ul><li><strong>先对数组的方法进行重写</strong>，因为push、pop、shift、unshift、reverse、sort、splice，因为这些方法会改变数组本身。</li> <li>然后通过调用<strong>observeArray</strong>方法，使数组里的引用类型定义成响应式，实际上就是通过遍历数组对每一项进行observe函数进行处理</li></ul></li></ol> <h2 id="_8-闭包在vue中的使用"><a href="#_8-闭包在vue中的使用" class="header-anchor">#</a> 8. 闭包在Vue中的使用</h2> <p>​	在definedReactive中，通过使用Object.definedProperty方法定义对象属性，当获取对象属性值时，返回的是上一个作用域的变量的值，即defiendReactive的值，所以defiendReactive函数不会被销毁</p> <h2 id="_9-vue2中性能缺点"><a href="#_9-vue2中性能缺点" class="header-anchor">#</a> 9. Vue2中性能缺点</h2> <p>​	vue2应用了defineProperty需要一加载的时候，就进行递归操作，所以耗费性能，如果层次过深也会浪费性能。</p> <blockquote><p>性能优化原则：</p></blockquote> <ol><li>不要把所有的数据都放在data中，因为所有数据都会增加get和set</li> <li>不要写数据的时候 层次过深，尽量扁平化数据</li> <li>不要频繁获取数据，因为每次获取数据都会触发getter函数的逻辑</li> <li>如果数据不需要响应式，可以使用Object.freeze冻结属性。</li></ol> <h2 id="_10-数组为什么不用defineproperty进行响应式处理"><a href="#_10-数组为什么不用defineproperty进行响应式处理" class="header-anchor">#</a> 10. 数组为什么不用defineProperty进行响应式处理</h2> <p>​	数组也可以使用defineProperty,但是我们很少采用 <code>arr[i] = xxx</code>，如果数组也使用了defineProperty还是可以实现修改索引触发更新的，但是这种操作概率低，所以源码没有采用这种方式。</p> <p>​	所以数组修改索引不会导致视图更新，修改length也不会更新。</p> <p>​	但是是vue3中为了兼容proxy，内部对数组用的就是defineProperty</p> <h2 id="_11-数组方法是如何重写的"><a href="#_11-数组方法是如何重写的" class="header-anchor">#</a> 11. 数组方法是如何重写的？</h2> <ol><li>会先调用数组原生的方法（通过apply方法改变this的指向）</li> <li>然后对于可以新增元素的方法（即push、unshift、splice），对其新增的元素通过observeArray方法进行数据劫持</li></ol> <h2 id="_12-defineproperty中除了get和set还有什么属性"><a href="#_12-defineproperty中除了get和set还有什么属性" class="header-anchor">#</a> 12 .defineProperty中除了get和set还有什么属性？</h2> <ul><li><code>enumrable</code>: 是否可枚举</li> <li><code>writable</code>：值是否可修改</li> <li><code>configurable</code>: 描述属性是否配置，以及是否删除</li></ul> <p>​	在已观测过的数据上增加<code>__ob_</code>属性， 其作用就是标识对象是否被观测过。其值为<code>Observe</code>类的实例</p> <p>​	为了避免在<code>this.walk</code>方法中造成无限递归，所以使用<code>enumrable</code>的属性设置<code>__ob__</code>设置为不可枚举。</p> <h2 id="_13-vue中初始化完成后-如何进行挂载呢"><a href="#_13-vue中初始化完成后-如何进行挂载呢" class="header-anchor">#</a> 13. Vue中初始化完成后，如何进行挂载呢？</h2> <div class="custom-block tip"><p class="title"></p><p>​	在vue中，通过调用<code>Vue.prototpe.$mount</code>方法进行数据的挂载。</p></div><p>在<code>$mount</code>中，主要进行了一下操作：</p> <ol><li>通过传入的<code>el</code>属性，获取页面真实的元素</li> <li>先判断用户是否传入render函数
<ul><li>存在render, 使用传入的render</li> <li>不存在render， 判断是否存在传入的template
<ul><li>存在template，直接使用template</li> <li>不存在template，通过compileToFunction的方法将传入的el.outerHTML编译成render函数</li></ul></li></ul></li> <li>获取render函数后， 通过mountComponent方法进行挂载。在方法中，主要通过调用render方法生成虚拟节点vnode, 传入render函数中调用的方法，<code>_c</code>、、、</li></ol> <h2 id="_14-vue中如何进行模板编译的"><a href="#_14-vue中如何进行模板编译的" class="header-anchor">#</a> 14. Vue中如何进行模板编译的？</h2> <div class="custom-block tip"><p class="title"></p><p>​	当Vue完成初始化阶段后，通过<code>$mount</code>的方法进入模板编译阶段。会去先判断是否存在render, 再去判断是否存在template，如果都没有，则会将传入的el元素通过outerHTML转为template 再将template编译成render函数，这其中通过<code>compileToFunction</code>进行转化</p></div><blockquote><p>compileToFunction具体操作：</p></blockquote> <ol><li>将template模板变成ast语法树 （parseHTML）</li></ol> <h2 id="_15-vue初始化过程"><a href="#_15-vue初始化过程" class="header-anchor">#</a> 15. Vue初始化过程？</h2> <ol><li>默认会调用<code>vue_init</code>方法将用户的参数挂载到<code>$option</code>选项中</li> <li>vue会根据用户的参数进行数据的初始化 <code>props、computed、watch</code>，会获取到对象作为数据，可以通过<code>vm._data</code>方法访问到用户的数据</li> <li>对数据进行观测：对象（递归使用defineProperty）、数组（方法重写）</li> <li>将数据代理到vm上</li> <li>判断用户是否传入了el属性，内部会调用<code>$mount</code>方法，此方法也可以用户自己调用</li> <li>对模板的优先级处理 render/template/ outerHTML</li> <li>将模板那编译成函数，parseHTML解析模板 -&gt; ast语法树，解析语法树生成code -&gt; render函数</li> <li>通过render方法，生成虚拟dom + 真实的数据 =》真实dom（<code>vm._render</code>方法，render函数转虚拟节点）</li> <li>根据虚拟节点渲染真实节点（<code>vm._updata</code>）</li></ol> <h2 id="_16-render函数为什么用with函数包裹"><a href="#_16-render函数为什么用with函数包裹" class="header-anchor">#</a> 16. render函数为什么用with函数包裹？</h2> <p>​	通过with函数传递作用域，获取变量的值时，可以通过上层作用域获取值。</p> <h2 id="_17-有了vnode之后如何生成真实dom-patch"><a href="#_17-有了vnode之后如何生成真实dom-patch" class="header-anchor">#</a> 17. 有了vnode之后如何生成真实dom （patch）</h2> <div class="custom-block tip"><p class="title"></p><p>​	通过<code>vm._render</code>方法创建vnode后，通过调用<code>vm._update</code>方法进行生成真实节点。<code>vm._update</code>函数在lifecycleMixin中定义，其<code>_update</code>方法主要通过<code>patch</code>方法将vnode生成真实dom</p></div><blockquote><p>patch方法</p></blockquote> <ol><li>删除老节点，根据vnode创建新节点，替换掉老节点</li></ol> <h2 id="_18-看源码思路"><a href="#_18-看源码思路" class="header-anchor">#</a> 18. 看源码思路</h2> <ol><li>先找package.json 找到 scripts.build</li> <li>找到打包时采用的入口方便分析 esm cjs / runtime 、compiler、full</li> <li>找到打包入口，文件在</li></ol> <h2 id="_19-如何将template转换成ast语法树-parserhtml"><a href="#_19-如何将template转换成ast语法树-parserhtml" class="header-anchor">#</a> 19.如何将template转换成AST语法树 <code>parserHTML</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	在<code>$mount</code>的方法中会通过<code>compilerTounctionn</code>将<code>template</code>转换成<code>render</code>函数，会先通过<code>parserHTML</code>将<code>template</code>转换成<code>AST</code>语法树</p></div><blockquote><p>parserHTML方法发生了什么？</p></blockquote> <p>parserHTML方法主要通过正则匹配构建ast语法树：</p> <ul><li><code>attribute</code> : 匹配标签属性正则</li> <li><code>ncname</code> : 匹配标签名正则</li> <li><code>qnameCapture</code>： 匹配命名空间正则</li> <li><code>startTagOpen</code>: 匹配开始标签的前半部分</li> <li><code>startTagClose</code>: 匹配开始标签的右尖部分</li> <li><code>endTag</code>： 匹配尾标签： <code>/&gt;</code> 或<code>&gt;</code></li> <li><code>doctype</code>: 匹配<code>!DOCTYPE</code></li> <li><code>comment</code>: 匹配注释</li> <li><code>defaultTagRE</code>: 匹配双大括号，<code></code></li></ul> <p><strong>思路</strong>： 通过不停地截取模板，直到把模板全部解析完毕</p> <ol><li><p>通过while循环，通过<code>advance</code>方法，将匹配到的内容从字符串中截取。获得匹配信息后通过栈来构建树形结构</p></li> <li><p>先获取<code>&lt;</code>在html的位置，如果位置index为0，则证明是开始标签或者是结束标签</p> <ul><li><p>如果匹配到开始标签</p> <ul><li><p>首先通过<code>parseStartTag</code>获取匹配后的<code>match</code>信息</p> <ol><li>构造一个<code>match</code>对象, 其包含<code>tagName</code>： 标签名、<code>attrs</code>： 属性等信息。</li> <li>然后通过循环匹配到属性信息，放入<code>match</code>对象中。</li> <li>然后通过匹配到尾标签，通过<code>advance</code>截取。</li> <li>最后返回<code>match</code>对象信息</li></ol></li> <li><p>将<code>match</code>信息放到<code>start</code>方法处理</p> <ol><li><p>遇到开始标签，就取栈中的最后一个作为父节点</p></li> <li><p>如果root为null，则说明当前节点为根节点，便把当前节点构造为一个root。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>root <span class="token operator">=</span> <span class="token punctuation">{</span>
	tag<span class="token punctuation">,</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 元素</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    p
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>并维护元素的<code>parent</code>属性，和维护父元素的<code>children</code>属性。</p></li></ol></li></ul></li> <li><p>如果是结束标签</p> <ul><li>将匹配到的信息放到<code>end</code>方法中处理， 就是把栈中的元素pop出去。</li></ul></li></ul></li> <li><p>如果匹配到文本，通过<code>text</code>方法处理， 直接接入到栈中最后一个元素的最后一项的children属性中。</p></li></ol> <h2 id="_20-vue3的模板编译原理与vue2的区别"><a href="#_20-vue3的模板编译原理与vue2的区别" class="header-anchor">#</a> 20. vue3的模板编译原理与vue2的区别</h2> <p>​	vue3的编译原理比vue2里好很多，没有这么多正则。</p> <h2 id="_21-如何通过ast语法树生成模板字符串-generate"><a href="#_21-如何通过ast语法树生成模板字符串-generate" class="header-anchor">#</a> 21. 如何通过ast语法树生成模板字符串？ <code>generate</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	通过调用调用<code>compileToFunction</code>的方法将<code>tamplate</code>生成<code>render</code>函数，在函数中会先通过<code>parseHTML</code>生成ast语法树，ast语法树构建完成之后，会通过<code>generate</code>方法，将ast语法树构建成模板字符串。</p></div><blockquote><p>generate方法具体发生了什么？</p></blockquote> <p>实际上genrate函数就是通过传入的ast语法树，进行字符串的拼接形成模板字符串。</p> <ul><li><code>_c</code>： 创建元素， <code>_c(标签名，属性，子元素)</code></li> <li>对于子元素的处理，就通过<code>genChildren</code>的方法递归调用generate的方法</li> <li>对于文本节点处理：
<ol><li>用<code>_v('文本内容')</code></li> <li>通过循环匹配表达式正则，处理<code></code>的情况，需要将xxx表达式转换成普通值，即将表达式用<code>_s()</code>进行包裹。</li></ol></li></ul> <h2 id="_22-如何将模板字符串转化成render函数呢"><a href="#_22-如何将模板字符串转化成render函数呢" class="header-anchor">#</a> 22. 如何将模板字符串转化成render函数呢？</h2> <div class="custom-block tip"><p class="title"></p><p>​	通过<code>$mount</code>方法进入vue的挂载阶段，会先去判断options中有没有<code>render</code>，再去判断有没有<code>template</code>，如果没有<code>template</code>，则将<code>el.outerHTml</code>转换为<code>template</code>，最后通过<code>compilerToFunction</code>方法将<code>template</code>转换为<code>render</code>函数，其中函数会先去调用<code>parseHTML</code>方法转化为<code>AST</code>语法树，然后再通过<code>generate</code>方法将<code>AST</code>语法树转换为模板字符串，最后通过<code>new Function</code>妆化为<code>render</code>函数</p></div><blockquote><p>new Function发生了什么？</p></blockquote> <p><code>let render = new Function(with(this){return ${模板字符串}})</code></p> <h2 id="_23-如何通过render构建成虚拟dom-render"><a href="#_23-如何通过render构建成虚拟dom-render" class="header-anchor">#</a> 23. 如何通过render构建成虚拟Dom, <code>_render</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	通过<code>parseHTML</code>获取ast语法树之后，通过递归调用<code>generate</code>构建模板字符串，再通过<code>new Function + with</code>的方法构建成render函数，最后获得的函数为<code>_c('标签名'， 属性，子元素)</code>， 主要通过<code>mountComponent</code>的方法对render方法进行调用，而<code>_render</code>方法主要在<code>renderMixin</code>的函数中进行原型上的挂载。</p></div><blockquote><p><code>renderMixin</code>函数是如何定义<code>render</code>的呢？</p></blockquote> <p>​	<code>mountComponent</code>函数主要就是对render方法的调用，而<code>vm._render</code>方法是在<code>renderMixin</code>的函数中在Vue原型挂载<code>_render</code>方法。</p> <p>在<code>renderMixin</code>的函数中除了定义<code>render</code>方法，还定义了诸多方法：</p> <ul><li><code>_c</code> : 创建元素型的节点, 实际上是调用<code>createElement</code>方法返回虚拟节点</li> <li><code>_v</code>： 创建文本型的节点， 实际上是调用<code>createText</code>方法返回虚拟节点</li> <li><code>_s</code>: JSON.stringify</li></ul> <p><code>_render</code>方法中核心就是执行render方法， 传入<code>_c</code>、<code>_v</code>、<code>_s</code>等函数。</p> <p>其中<code>createElement</code>、<code>createText</code>等方法实际就是通过传入不同的参数，实例化<code>Vnode</code>的方法，创建 不同的虚拟DOM。</p> <blockquote><p>虚拟DOM结果如下：</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">VNode</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>
    <span class="token parameter">tag<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
    data<span class="token operator">?</span><span class="token operator">:</span> VNodeData<span class="token punctuation">,</span>
    children<span class="token operator">?</span><span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    text<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
    elm<span class="token operator">?</span><span class="token operator">:</span> Node<span class="token punctuation">,</span>
    context<span class="token operator">?</span><span class="token operator">:</span> Component<span class="token punctuation">,</span>
    componentOptions<span class="token operator">?</span><span class="token operator">:</span> VNodeComponentOptions<span class="token punctuation">,</span>
    asyncFactory<span class="token operator">?</span><span class="token operator">:</span> Function</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 当前节点的标签名 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag
    <span class="token comment">/* 当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
    <span class="token comment">/* 当前节点的子节点，是一个数组 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> children
    <span class="token comment">/* 当前节点的文本 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text
    <span class="token comment">/* 当前虚拟节点的真实dom节点 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>elm <span class="token operator">=</span> elm
    <span class="token comment">/* 当前节点的名字空间 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ns <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/* 编译作用域 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context
    <span class="token comment">/* 函数化组件作用域 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>fnContext <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/* 函数化组件的option选项 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>fnOptions <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>fnScopeId <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/* 节点的key属性，被当做节点的标志，用于优化 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> data <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>key
    <span class="token comment">/* 组价的option选项 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>componentOptions <span class="token operator">=</span> componentOptions
    <span class="token comment">/* 当前节点对应的组件的实例 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/* 当前节点的父节点 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">/* 是否是原生HTML或者只是普通文本，innerHTML的时候是true. textContent的时候是false */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>raw <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/* 静态节点标志 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isStatic <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/* 作为根节点插入 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isRootInsert <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">/* 是否为注释接地那 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isComment <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/* 是否为克隆节点 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isCloned <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token comment">/* 是否有v-once指令 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isOnce <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>asyncFactory <span class="token operator">=</span> asyncFactory
    <span class="token keyword">this</span><span class="token punctuation">.</span>asyncMeta <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>isAsyncPlaceholder <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br></div></div><h2 id="_24-为什么有了ast语法树-还需要vnode呢"><a href="#_24-为什么有了ast语法树-还需要vnode呢" class="header-anchor">#</a> 24. 为什么有了ast语法树，还需要vnode呢？</h2> <p>​	其实vnode其实就是一个对象，用来描述节点的，这个和ast语法树长得很像啊？</p> <p>​	ast语法树描述语法的，它并没有用户自己的逻辑，只是语法解析出来的内容。</p> <p>​	vnode，它是描述dom结构的，可以扩展属性。</p> <h2 id="_25-虚拟节点如何去渲染成真实节点呢-update"><a href="#_25-虚拟节点如何去渲染成真实节点呢-update" class="header-anchor">#</a> 25. 虚拟节点如何去渲染成真实节点呢？ <code>_update</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	通过<code>compilerToFunction</code>将<code>template</code>转换成<code>render</code>函数后，通过调用<code>mountComponent</code>的方法，去运行render函数，将render函数转换为虚拟节点，实际就是执行render函数中的<code>_c、_v、_s</code>等方法，而这些方法实际上就是通过传入不同的参数，实例化<code>VNode</code>的一个类，创建虚拟节点。当创建完虚拟节点后，还需要在<code>mountComponent</code>方法中，调用<code>vm._update</code>的方法进行实例的挂载。</p></div><p>​	通过<code>_render</code>方法构建好虚拟节点后，通过<code>_update</code>方法将虚拟节点变成真实节点。</p> <p>​	而<code>_update</code>方法，在<code>lifecycleMixin</code>函数中挂载到<code>Vue</code>的原型上的。其核心思想就是，采用的是先序深度遍历，创建节点（也就是遇到节点就创建节点，递归创建）。</p> <p>核心通过<code>patch</code>方法将虚拟节点转换为真实节点。</p> <p><code>patch</code>方法需要传入两个参数:</p> <ul><li>oldVnode : 旧节点</li> <li>Vnode : 新节点</li></ul> <p><code>patch</code>方法就是主要通过删除老节点oldVnode，根据vnode创建新节点，替换掉老节点。</p> <ol><li><code>patch</code>方法先通过<code>createElm</code>方法通过虚拟节点vnode创建真实节点。</li> <li>通过<code>nextSibing</code>方法获取旧节点的下一个节点</li> <li>然后通过<code>insertBefore</code>方法，将新创建的元素插入到旧节点下一个元素的前面 。如果通过<code>nextSibing</code>获取的值为null，则<code>insertBefore</code>就相当于<code>appendChild</code></li> <li>然后通过<code>removeChild</code>的方法将旧节点删除掉。</li></ol> <h2 id="_26-如果通过虚拟vnode创建元素呢-createelm"><a href="#_26-如果通过虚拟vnode创建元素呢-createelm" class="header-anchor">#</a> 26. 如果通过虚拟vnode创建元素呢？ <code>createElm</code></h2> <ol><li>如果是元素节点，先通过<code>document.createElement</code>方法创建元素，如果该vnode还具有<code>children</code>属性，则通过递归调用<code>createElm</code>方法创建子节点， 并通过<code>appendChild</code>方法将子节点添加入元素中。</li> <li>并且在vnode上添加el属性（<code>vnode.el</code>），让虚拟节点和真实节点做一个映射关系，后续某个虚拟节点更新了，可以跟踪真实节点，并更新真实节点。</li> <li>对于元素的属性等，通过<code>updateProperties</code>方法进行处理，通过循环调用<code>setAttribute</code>方法添加属性。样式等处理后续完善。</li></ol> <h2 id="_27-vue更新阶段是怎么做的"><a href="#_27-vue更新阶段是怎么做的" class="header-anchor">#</a> 27. vue更新阶段是怎么做的？</h2> <div class="custom-block tip"><p class="title"></p><p>​	从调用<code>_init</code>的方法进行初始化，然后调用<code>$mount</code>的方法进行挂载，先通过<code>compilerToFunction</code>方法将<code>template</code>转化为<code>render</code>函数，然后通过调用<code>_render</code>方法将<code>render</code>函数转化为<code>vnode</code>, 最后通过<code>patch</code>方法对<code>vnode</code>生成真实dom进行过载。</p></div><ul><li>只有根组件的情况： （每个属性都有一个dep）
<ol><li>vue里面用到了观察者模式，默认组件渲染的时候，会创建一个watcher，（并渲染视图）</li> <li>当渲染视图的时候，会取date中的数据，会走每个属性的get方法，就让这个属性的dep记录watcher</li> <li>同时让watcher也记住dep，（dep和watcher是多对多的关系，因为一个属性可能对应多个视图，一个视图对应多个数据）</li> <li>如果数据发生变化，会通知对应的属性的dep，依次通知存放的watcher去更新。</li></ol></li></ul> <h2 id="_28-vue中对象是如何更新的"><a href="#_28-vue中对象是如何更新的" class="header-anchor">#</a> 28. vue中对象是如何更新的？</h2> <blockquote><p>核心思路</p></blockquote> <ul><li><strong>一个属性对应一个dep</strong>: 一个属性可以在A组件和B组件里使用, 所以一个属性对应一个dep</li> <li><strong>一个dep对应多个watcher</strong>： dep里存了A组件的watcher和B组件的watcher,所以一个dep对应斗个watcher</li> <li><strong>一个watcher可以对应多个dep</strong>： 视图有多个数据，多个数据对应多个dep，所以一个watcher可以有多个dep</li></ul> <div class="custom-block tip"><p class="title"></p><p>可以理解 为： 一个组件对应一个watcher， 而watcher的目的就是用于更新。</p></div><div class="custom-block tip"><p class="title"></p><p>​	当通过<code>compilerToFunction</code>方法生成render方法后，实际是通过<code>vm._update(vm._render)</code>执行，进行挂载，而源码中该函数执行即为<code>updateComponent</code>中。所以更新逻辑主要就是通过调用<code>updateComponent</code>执行。所以对象更新的核心思路就是： 如果数据变化了，可以调用<code>updateComponent</code>方法。所以可以借助<code>watcher</code>的概念，如果数据变了可以自动调用<code>updateCompoent</code>方法</p></div><blockquote><p>函数主要通过mountComponent方法进行更新挂载：</p></blockquote> <ol><li>初始化的时候通过调用<code>updateComponent</code>方法，即<code>vm._update(vm._render)</code>方法进行更新</li> <li>然后通过实例化渲染Watcher， 当数据变化的时候，调用<code>updateComponent</code>方法</li></ol> <h2 id="_29-vue中的更新逻辑和发布订阅有啥区别"><a href="#_29-vue中的更新逻辑和发布订阅有啥区别" class="header-anchor">#</a> 29. vue中的更新逻辑和发布订阅有啥区别</h2> <p>发布订阅是手动触发更新，而vue则是自动触发更新的。</p> <h2 id="_30-watcher类是如何实现的"><a href="#_30-watcher类是如何实现的" class="header-anchor">#</a> 30. Watcher类是如何实现的？</h2> <ul><li><p>Watcher更新时，传入五个参数</p> <ul><li><code>vm</code>: vue实例</li> <li><code>expOrFn</code>： 页面渲染逻辑</li> <li><code>cb</code> : 回调函数</li> <li><code>options</code>:</li> <li><code>isRenderWatcher</code>: 是否为渲染Watcher</li></ul></li> <li><p>传入参数后，进行参数处理</p> <ul><li><code>this.getter = fn</code> ：fn就是页面渲染逻辑</li></ul></li> <li><p>然后调用get方法，进行初始化<code>Watcher</code>。</p> <ol><li>调用<code>pushTarget</code>, 将当前Watcher放入到<code>Dep.target</code>中，用于依赖收集。</li> <li>调用<code>this.getter</code>方法， 进行渲染逻辑</li> <li>这样就可以保证之后当前渲染到的属性才能获取到当前的<code>Watcher</code></li></ol></li> <li><p>当收集依赖的时候，会调用到<code>addDep</code>方法</p> <ol><li>其中维护着一个数组newDepIds， 用于Dep去重</li> <li>然后把传入的Dep加入到<code>newDeps</code>中将Dep存储起来</li> <li>然后通过调用<code>dep.addSub</code>的方法，将当前的<code>Watcher</code>存储入<code>Dep</code>的<code>subs</code>数组中。</li></ol></li></ul> <h2 id="_31-dep类是如何实现的"><a href="#_31-dep类是如何实现的" class="header-anchor">#</a> 31. Dep类是如何实现的？</h2> <ol><li><p>Dep的属性：</p> <ul><li><code>subs</code>: 用于存放<code>Watcher</code>的数组</li> <li><code>id</code> : 用于做唯一标识</li> <li><code>target</code>： 表示当前依赖的目标是谁（哪个Watcher）</li></ul></li> <li><p>当用户取属性时，会触发<code>depend</code>的方法，调用<code>Watcher</code>即<code>Dep.target</code>的<code>addDep</code>方法， 用于<code>Dep</code>去重，然后Watcher存储当前dep , 然后调用<code>addSub</code>方法。</p></li> <li><p>当调用<code>addSub</code>方法，就是将当前Watcher存入<code>subs</code>数组中</p></li></ol> <h2 id="_32-依赖收集的过程-dep-append"><a href="#_32-依赖收集的过程-dep-append" class="header-anchor">#</a> 32. 依赖收集的过程？<code>Dep.append</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	进行数据初始化的时候，如果是传入的值是对象的话通过调用<code>walk</code>方法，循环调用<code>defineReactive</code>方法对每个属性继续数据劫持。所以要为每个属性增加Dep的话，可以在<code>defineReactive</code>中定义。</p></div><ol><li>页面更新的时候，会调用<code>mountComponent</code>的方法，在该方法中会在实例化一个渲染<code>Watcher</code>, 然后调用<code>Watcher</code>中的<code>get</code>方法，主要做以下工作：
<ul><li>调用<code>pushTarget</code>， 将当前<code>Watcher</code>放到<code>Dep.target</code>的属性中</li> <li>然后调用<code>updateComponent</code>的方法，进行初渲染</li> <li>然后通过<code>popTarget</code>，重置<code>Dep.target</code>的值</li></ul></li> <li>当用户取值时， 会调用<code>defineProperty</code>的<code>get</code>方法，这时触发<code>Dep.append</code></li> <li>在<code>Dep.append</code>的方法中，会调用<code>Dep.target</code>（即<code>Watcher</code>）的addDep方法进行收集Watcher</li> <li>而<code>Watcher.addDep</code>方法，会通过id的方法，用Set的数据结构先对Dep进行去重，然后将<code>dep</code>收集到<code>newDeps</code>数组中，然后调用<code>Dep.addSub</code>方法，将当前Watcher放到<code>Dep.subs</code>数组中</li> <li>这样dep就收集到了多个<code>Watcher</code>, 而<code>Watcher</code>也收集到了<code>Dep</code></li></ol> <h2 id="_33-依赖收集后-数据该如何进行更新呢-dep-notify-watcher-update"><a href="#_33-依赖收集后-数据该如何进行更新呢-dep-notify-watcher-update" class="header-anchor">#</a> 33. 依赖收集后，数据该如何进行更新呢？<code>Dep.notify</code> <code>Watcher.update</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	用户取数据后，会调用<code>defineProperty</code>的get方法，进行依赖收集，即<code>Dep</code>获取多个<code>Watcher</code>, <code>Watcher</code>也获取了多个<code>Dep</code></p> <p>​	当用户修改数据的时候，会调用<code>Dep.notify</code>方法，进行数据更新。</p></div><blockquote><p>notify实现逻辑？</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// stabilize the subscriber list first</span>
    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	实际上的操作就是，通过循环<code>subs</code>数组中收集的<code>Watcher</code>，调用<code>Watcher</code>中的<code>update</code>方法， 实际上就是调用<code>Watcher</code>的<code>get</code>方法，进行渲染（<code>updateComponent</code>）</p> <p>​	再<code>update</code>方法中可以做异步更新逻辑。</p> <h2 id="_34-如何实现vue的异步更新逻辑-queuewatcher"><a href="#_34-如何实现vue的异步更新逻辑-queuewatcher" class="header-anchor">#</a> 34. 如何实现vue的异步更新逻辑？<code>queueWatcher</code></h2> <div class="custom-block tip"><p class="title"></p><p>​	当用户更新数据时，会调用<code>defineProperty</code>中的<code>set</code>方法，设置值后，会调用<code>Dep.notify</code>方法，进行循环调用<code>Watcher</code>中的<code>update</code>方法。</p> <p>​	由于每次更新数据都会调用这个update方法，我们可以将更新的逻辑缓存起来，等到同步更新数据的逻辑执行完毕后，依次调用（含有去重逻辑）</p></div><p>每次更新调用<code>update</code>方法，都会执行其<code>queueWatcher</code>方法</p> <ul><li><strong>去重</strong>： 维护着<code>has</code>数组，用于存储已有的<code>Watcher</code>的<code>id</code>， 用<code>has[id] == null</code>来判断是否重复</li> <li><strong>缓存</strong>： 通过维护则<code>queue</code>队列，每次把<code>watcher</code>都存放入<code>queue</code>队列当中。</li> <li><strong>防抖</strong>: 通过维护着<code>waitting</code>变量，默认值为false，只有清空<code>queue</code>中的watcher才会设置为<code>true</code></li> <li><strong>异步</strong>： 当<code>waitting</code>变量为<code>fasle</code>， 才会设置nextTick，清空queue队列，然后执行<code>flushSchedulerQueue</code>的方法，实际就是遍历每个watcher执行其<code>run()</code>的方法。</li></ul> <h2 id="_35-vue3和vue2中nexttick的区别"><a href="#_35-vue3和vue2中nexttick的区别" class="header-anchor">#</a> 35. vue3和vue2中nextTick的区别？</h2> <p>vue3里面的nextTick就是promise, vue2里面做了一些兼容性处理</p> <h2 id="_36-nexttick是如何实现的"><a href="#_36-nexttick是如何实现的" class="header-anchor">#</a> 36. nextTick是如何实现的？</h2> <div class="custom-block tip"><p class="title"></p><p>​	当用户更新的时候，会调用<code>Dep.notify</code>方法，将<code>Dep</code>中的每一个<code>Watcher</code>的<code>update</code>方法，而<code>update</code>实际就是调用<code>queueWatcher</code>的方法，去对watcher进行去重、缓存、节流和异步执行，而异步执行就是调用<code>nextTick</code>的方法实现的。</p></div><p>​	但是<code>nextTick</code>的方法，有vue内部的，用户也可以通过<code>$nextTick</code>方法进行定义。</p> <p>​	所以，nextTick中也维护着一个<code>pending</code>变量，用于对nextTick多次执行，只调用一次。</p> <p>​	并且维护着一个数组<code>callbacks</code>, 存放着调用<code>nextTick</code>所有的回调函数，等同步代码执行完再调用<code>flushCallbacks</code>方法进行异步执行，清空<code>callbacks</code>数组。即多次nextTick，只执行一次<code>then</code>方法</p> <h2 id="_37-数组如何依赖收集-数组更新时-又如何触发更新"><a href="#_37-数组如何依赖收集-数组更新时-又如何触发更新" class="header-anchor">#</a> 37.数组如何依赖收集？数组更新时，又如何触发更新？</h2> <div class="custom-block tip"><p class="title"></p><p>​	对数据进行响应式观测的时候，会调用<code>observe</code>的方法进行观测，然后在<code>observer</code>方法中，进行<code>new Observer</code>实例化</p></div><blockquote><p>数组依赖收集</p></blockquote> <ol><li>在实例化<code>Observer</code>类的时候，添加<code>dep</code>属性，值为<code>new Dep</code></li> <li>当取属性值时，会调用<code>defineProperty</code>的<code>get</code>方法，在get方法中，调用数组或对象的Observer实例上的<code>dep.depend()</code>进行依赖收集</li> <li>如果是数组中嵌套着数组，通过调用<code>dependArray</code>方法，遍历数组每一项，调用<code>__ob__</code>的<code>dep.depend</code>方法，进行依赖收集，再递归调用<code>dependArray</code>。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">dependArray</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> e<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e <span class="token operator">=</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>__ob__ <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>__ob__<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">dependArray</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>数组触发更新</p></blockquote> <div class="custom-block tip"><p class="title"></p><p>​	对于数组的响应式处理，是通过重写数组的七个方法进行处理的，只需要在重写的方法中，再调用数组本身的<code>dep.notify</code>方法。</p></div><h2 id="_38-vue的响应式原理"><a href="#_38-vue的响应式原理" class="header-anchor">#</a> 38. vue的响应式原理</h2> <ol><li>默认vue在初始化的时候，会对对象每个属性都进行劫持，增加dep属性，当取值的时候会做依赖收集</li> <li>默认还会对属性值是对象和 数组的本身进行增加dep属性，进行依赖收集</li> <li>如果属性变化，触发属性对应的dep去更新</li> <li>如果是数组更新，触发数组的本身的dep 进行更新</li> <li>如果取值的时候是数组还要让数组中的对象类型也进行依赖收集（递归依赖收集）</li> <li>如果数组里面放对象，默认对象里的属性是会进行依赖收集的，因为在取值时，会进行<code>JSON.stringify</code>操作。</li></ol> <h2 id="_39-vue中的生命周期是如何实现的"><a href="#_39-vue中的生命周期是如何实现的" class="header-anchor">#</a> 39. vue中的生命周期是如何实现的？</h2> <h2 id="_40-vue-mixin方法的实现"><a href="#_40-vue-mixin方法的实现" class="header-anchor">#</a> 40 Vue.mixin方法的实现？</h2> <div class="custom-block tip"><p class="title"></p><p><code>Vue.mixin</code>:全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。</p></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>  Vue<span class="token punctuation">.</span><span class="token function-variable function">mixin</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">mixin</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 合并选项 */</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">,</span> mixin<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	通过<code>mergeOptions</code>将传入的<code>mixin</code>对象与<code>this.options</code>合并，然后将合并后的新对象作为<code>this.options</code>传给之后的所有<code>Vue</code>实例</p> <h2 id="_41-vue中声明周期如何触发钩子函数-callhook"><a href="#_41-vue中声明周期如何触发钩子函数-callhook" class="header-anchor">#</a> 41. vue中声明周期如何触发钩子函数 <code>callHook</code></h2> <blockquote><p>简易版的实现</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">callHook</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> hook</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> handlers <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">[</span>hook<span class="token punctuation">]</span><span class="token punctuation">;</span>
    handlers <span class="token operator">&amp;&amp;</span> handlers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">item</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生命周期的this永远指向实例</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol><li>先在<code>vm.$options</code>找到对应的钩子函数</li> <li>然后通过<code>forEach</code>循环调用</li></ol> <h2 id="_42-vue-diff算法如何实现"><a href="#_42-vue-diff算法如何实现" class="header-anchor">#</a> 42. vue Diff算法如何实现？</h2> <div class="custom-block tip"><p class="title"></p><p>​	通过<code>patch(oldVnode, newVnode)</code>，比对两个虚拟节点的差异，更新需要更新的地方。</p> <p>​	当<code>oldVnode</code>是真实元素，实际走的是一个初始化流程，否则才走diff算法流程</p></div><ol><li>通过调用<code>sameVnode</code>方法，判断新旧节点的<code>key</code>和<code>tag</code>值，判断是否是同一个节点</li></ol> <h2 id="_43-diff算法中有啥性能问题"><a href="#_43-diff算法中有啥性能问题" class="header-anchor">#</a> 43. diff算法中有啥性能问题？</h2> <p>​	因为diff只是同级的比对，但整颗diff树中，只有一个节点发生变化，需要递归整棵diff树进行比对，会有性能的损耗。</p> <p>​	而vue3中会把动态节点（做标记）抽离到一个数组中，当diff比对时，只需要对数组中的元素进行处理即可。</p> <h2 id="_44-为什么用类来检测数据变化-而不是使用对象"><a href="#_44-为什么用类来检测数据变化-而不是使用对象" class="header-anchor">#</a> 44. 为什么用类来检测数据变化，而不是使用对象</h2> <p>​	类具有类型，可以知道谁是谁的实例，而对象没有类型，如果需要知道一个对象有没有监控过，只需要看是否是Observer的实例即可，而且方便扩展</p> <h2 id="_45-watch的deep原理"><a href="#_45-watch的deep原理" class="header-anchor">#</a> 45. watch的deep原理</h2> <p>​	watch方法原理内部会通过创建一个<code>watcher</code>实例的方法，进行数据的依赖收集，当依赖变化的时候会调用用户传入的方法。</p> <p>​	当<code>deep</code>属性设置为<code>true</code>时，表示进行深度观察。只需要在创建<code>watcher</code>实例的时候把<code>obj</code>对象所有的值都递归读一遍，那么这个<code>watcher</code>实例就会被加到对象内所有值的依赖列表中，之后当对象任意某个值发生变化时就能得到通知。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2022/4/13 02:41:11</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/docs/04-vue/02-sheng-ming-zhou-qi.html">
            Vue02 生命周期
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_1-vue的基本原理" class="sidebar-link reco-side-_1-vue的基本原理" data-v-70334359>1. Vue的基本原理</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_2-双向数据绑定的原理" class="sidebar-link reco-side-_2-双向数据绑定的原理" data-v-70334359>2. 双向数据绑定的原理</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_3-data什么情况是对象-函数" class="sidebar-link reco-side-_3-data什么情况是对象-函数" data-v-70334359>3. data什么情况是对象？函数？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_4-vue的初始化流程" class="sidebar-link reco-side-_4-vue的初始化流程" data-v-70334359>4. vue的初始化流程</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_5-vue中如何处理传入的data数据" class="sidebar-link reco-side-_5-vue中如何处理传入的data数据" data-v-70334359>5. Vue中如何处理传入的data数据</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_6-如何将传入的data变成响应式" class="sidebar-link reco-side-_6-如何将传入的data变成响应式" data-v-70334359>6. 如何将传入的data变成响应式？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_7-vue中如何识别被观测过的数据" class="sidebar-link reco-side-_7-vue中如何识别被观测过的数据" data-v-70334359>7. Vue中如何识别被观测过的数据？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_8-闭包在vue中的使用" class="sidebar-link reco-side-_8-闭包在vue中的使用" data-v-70334359>8. 闭包在Vue中的使用</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_9-vue2中性能缺点" class="sidebar-link reco-side-_9-vue2中性能缺点" data-v-70334359>9. Vue2中性能缺点</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_10-数组为什么不用defineproperty进行响应式处理" class="sidebar-link reco-side-_10-数组为什么不用defineproperty进行响应式处理" data-v-70334359>10. 数组为什么不用defineProperty进行响应式处理</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_11-数组方法是如何重写的" class="sidebar-link reco-side-_11-数组方法是如何重写的" data-v-70334359>11. 数组方法是如何重写的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_12-defineproperty中除了get和set还有什么属性" class="sidebar-link reco-side-_12-defineproperty中除了get和set还有什么属性" data-v-70334359>12 .defineProperty中除了get和set还有什么属性？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_13-vue中初始化完成后-如何进行挂载呢" class="sidebar-link reco-side-_13-vue中初始化完成后-如何进行挂载呢" data-v-70334359>13. Vue中初始化完成后，如何进行挂载呢？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_14-vue中如何进行模板编译的" class="sidebar-link reco-side-_14-vue中如何进行模板编译的" data-v-70334359>14. Vue中如何进行模板编译的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_15-vue初始化过程" class="sidebar-link reco-side-_15-vue初始化过程" data-v-70334359>15. Vue初始化过程？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_16-render函数为什么用with函数包裹" class="sidebar-link reco-side-_16-render函数为什么用with函数包裹" data-v-70334359>16. render函数为什么用with函数包裹？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_17-有了vnode之后如何生成真实dom-patch" class="sidebar-link reco-side-_17-有了vnode之后如何生成真实dom-patch" data-v-70334359>17. 有了vnode之后如何生成真实dom （patch）</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_18-看源码思路" class="sidebar-link reco-side-_18-看源码思路" data-v-70334359>18. 看源码思路</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_19-如何将template转换成ast语法树-parserhtml" class="sidebar-link reco-side-_19-如何将template转换成ast语法树-parserhtml" data-v-70334359>19.如何将template转换成AST语法树 parserHTML</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_20-vue3的模板编译原理与vue2的区别" class="sidebar-link reco-side-_20-vue3的模板编译原理与vue2的区别" data-v-70334359>20. vue3的模板编译原理与vue2的区别</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_21-如何通过ast语法树生成模板字符串-generate" class="sidebar-link reco-side-_21-如何通过ast语法树生成模板字符串-generate" data-v-70334359>21. 如何通过ast语法树生成模板字符串？ generate</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_22-如何将模板字符串转化成render函数呢" class="sidebar-link reco-side-_22-如何将模板字符串转化成render函数呢" data-v-70334359>22. 如何将模板字符串转化成render函数呢？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_23-如何通过render构建成虚拟dom-render" class="sidebar-link reco-side-_23-如何通过render构建成虚拟dom-render" data-v-70334359>23. 如何通过render构建成虚拟Dom, _render</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_24-为什么有了ast语法树-还需要vnode呢" class="sidebar-link reco-side-_24-为什么有了ast语法树-还需要vnode呢" data-v-70334359>24. 为什么有了ast语法树，还需要vnode呢？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_25-虚拟节点如何去渲染成真实节点呢-update" class="sidebar-link reco-side-_25-虚拟节点如何去渲染成真实节点呢-update" data-v-70334359>25. 虚拟节点如何去渲染成真实节点呢？ _update</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_26-如果通过虚拟vnode创建元素呢-createelm" class="sidebar-link reco-side-_26-如果通过虚拟vnode创建元素呢-createelm" data-v-70334359>26. 如果通过虚拟vnode创建元素呢？ createElm</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_27-vue更新阶段是怎么做的" class="sidebar-link reco-side-_27-vue更新阶段是怎么做的" data-v-70334359>27. vue更新阶段是怎么做的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_28-vue中对象是如何更新的" class="sidebar-link reco-side-_28-vue中对象是如何更新的" data-v-70334359>28. vue中对象是如何更新的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_29-vue中的更新逻辑和发布订阅有啥区别" class="sidebar-link reco-side-_29-vue中的更新逻辑和发布订阅有啥区别" data-v-70334359>29. vue中的更新逻辑和发布订阅有啥区别</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_30-watcher类是如何实现的" class="sidebar-link reco-side-_30-watcher类是如何实现的" data-v-70334359>30. Watcher类是如何实现的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_31-dep类是如何实现的" class="sidebar-link reco-side-_31-dep类是如何实现的" data-v-70334359>31. Dep类是如何实现的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_32-依赖收集的过程-dep-append" class="sidebar-link reco-side-_32-依赖收集的过程-dep-append" data-v-70334359>32. 依赖收集的过程？Dep.append</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_33-依赖收集后-数据该如何进行更新呢-dep-notify-watcher-update" class="sidebar-link reco-side-_33-依赖收集后-数据该如何进行更新呢-dep-notify-watcher-update" data-v-70334359>33. 依赖收集后，数据该如何进行更新呢？Dep.notify Watcher.update</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_34-如何实现vue的异步更新逻辑-queuewatcher" class="sidebar-link reco-side-_34-如何实现vue的异步更新逻辑-queuewatcher" data-v-70334359>34. 如何实现vue的异步更新逻辑？queueWatcher</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_35-vue3和vue2中nexttick的区别" class="sidebar-link reco-side-_35-vue3和vue2中nexttick的区别" data-v-70334359>35. vue3和vue2中nextTick的区别？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_36-nexttick是如何实现的" class="sidebar-link reco-side-_36-nexttick是如何实现的" data-v-70334359>36. nextTick是如何实现的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_37-数组如何依赖收集-数组更新时-又如何触发更新" class="sidebar-link reco-side-_37-数组如何依赖收集-数组更新时-又如何触发更新" data-v-70334359>37.数组如何依赖收集？数组更新时，又如何触发更新？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_38-vue的响应式原理" class="sidebar-link reco-side-_38-vue的响应式原理" data-v-70334359>38. vue的响应式原理</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_39-vue中的生命周期是如何实现的" class="sidebar-link reco-side-_39-vue中的生命周期是如何实现的" data-v-70334359>39. vue中的生命周期是如何实现的？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_40-vue-mixin方法的实现" class="sidebar-link reco-side-_40-vue-mixin方法的实现" data-v-70334359>40 Vue.mixin方法的实现？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_41-vue中声明周期如何触发钩子函数-callhook" class="sidebar-link reco-side-_41-vue中声明周期如何触发钩子函数-callhook" data-v-70334359>41. vue中声明周期如何触发钩子函数 callHook</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_42-vue-diff算法如何实现" class="sidebar-link reco-side-_42-vue-diff算法如何实现" data-v-70334359>42. vue Diff算法如何实现？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_43-diff算法中有啥性能问题" class="sidebar-link reco-side-_43-diff算法中有啥性能问题" data-v-70334359>43. diff算法中有啥性能问题？</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_44-为什么用类来检测数据变化-而不是使用对象" class="sidebar-link reco-side-_44-为什么用类来检测数据变化-而不是使用对象" data-v-70334359>44. 为什么用类来检测数据变化，而不是使用对象</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/04-vue/01-vueji-chu.html#_45-watch的deep原理" class="sidebar-link reco-side-_45-watch的deep原理" data-v-70334359>45. watch的deep原理</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:250px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><!----></div></div></div>
    <script src="/blog/assets/js/app.ce36d364.js" defer></script><script src="/blog/assets/js/3.69e5ab97.js" defer></script><script src="/blog/assets/js/1.d241725f.js" defer></script><script src="/blog/assets/js/32.86fb3e55.js" defer></script><script src="/blog/assets/js/8.a8350c27.js" defer></script>
  </body>
</html>
