---
title: 手撕00 算法
date: 2022-03-24
sidebar: 'auto'
categories:
- 06手撕
isShowComments: true
---



## 1. BFS算法套路框架

```js
// 计算从起点start到终点target的最近距离
function BFS(start, target) {
	let q = []; // 核心数据结构：队列
    let visited = new Set(); // 避免走回头路
    
    q.push(start); //将起点加入队列
    visited.add(start);
    let step = 0; // 记录扩散的步数
    
    let sz;
    let cur;
    while (!q.length){
        sz = q.length;
        /* 将当前队列中的所有节点向四周扩散 */
        for(let i = 0;i<sz;i++) {
			cur = q.shift();
            /* 划重点：这里判断是否到达重点 */
            if (cur == target) {
				return step;
            }
            /* 将cur的相邻节点加入队列 */
            for( 所有相邻节点的情况判断 ) {
				if (x not in visited) {
					q.push(x);
                    visited.add(x);
                }
            }
        }
    }
   
}
```



## 2. 岛屿问题框架

> **经典岛屿问题**：[岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
    // 获取行列数
    let rows = grid.length, columns = grid[0].length;
    // 存储结果
    let res = 0;
	
    // 遍历二维数组框架：把遇到的岛屿淹没
    let dfs = (grid, row, column) => {
        if (row < 0 || column < 0 || row > rows - 1 || column > columns - 1) {
            return
        }

        if (grid[row][column] == '0') {
            return
        }

        grid[row][column] = '0'
        dfs(grid, row + 1, column);
        dfs(grid, row - 1, column);
        dfs(grid, row, column + 1);
        dfs(grid, row, column - 1);
    }
	
    // 双重循环遍历二维数组的每
    for (let row = 0; row < rows; row++) {
        for (let column = 0; column < columns; column++) {
            if (grid[row][column] == '1') {
                res++;
                dfs(grid, row, column);
            }
        }
    }
    return res;
};
```

