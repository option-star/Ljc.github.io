---
title: 业务07 代码解读
date: 2022-04-24
sidebar: 'auto'
categories:
- 12常见业务
isShowComments: true
---

## 1. 介绍

​	此前端代码采用了单页应用写法, 即所有功能在一个页面中, 所以我们仅有一个前端文件(index.js) 这个前端文件表现节点 的所有功能。大家可能会认为, 代码写在了一起是不是很臃肿,代码很多很乱很长，其实不然, 写在一起也是综合了各种因素权衡,主要权衡指标为 开发者前端基础, 改写代码习惯，和后端转前端的同学, 尽量避免this指针, 不用理解call调用, 能用一种整齐划一的方式，让大家理解简单，上手方便. 当你了解了代码的基本结构后, 你一定会觉得简单的不可思议。非常不建议在节点应用中使用现在的多页面模式方案。好处你一定会体会到。



## 2. 必备知识

### 1）react 运作方式

​	模型模型驱动视图改变, 视图被监听修改模型，再次驱动视图改变.  这种单向变化解决了节点所有功能。

- 模型模型驱动视图改变 -> 可以理解为视图在表现模型,  在react中 state变化了, 会调用render方法重新渲染,即根据新模型重新画视图.
- 视图被监听修改模型  -> 视图可以添加各种监听事件，(click, mourseMove)等, 事件处理时, 修改模型. 模型变化驱动了视图重新表现。

```js
          —————>>————————
         |               |
        模型(state)     视图(render)
         |               |
         -----<<----------
```



### 2）平台的高阶组件

​	平台的高阶组件是 props.组件.方法 这种调用形式的组件. 高阶组件最终底层还是 react运作模式. 需要掌握高阶组件API. 平台的高阶组件会经常用到.

### 3） 代码的基本结构

​	代码中, 最核心3方法，分别是构造方法constructor方法, 创建模型方法createState方法， 渲染方法render方法， 当然还是其他的定义，比如监听事件处理, 按钮状态控制方法，但是当你掌握了这3个最核心的方法, 你基本及掌握了整个页面的运作模式，结构模型了. 在介绍其他方法就一目了然了.

#### 1] constructor

`constructor`的作用为构造当前页面对象。主要职责为

1. 加载NC资源，如单据模板, 按钮定义。 修正模板的一些属性。
2. 调用创建模型方法createState方法，构建页面的结构(*), 核心方法。
3.  保存和定义节点配置项，如节点编码，应用编码等。



#### 2] createState方法，render方法

​	createState方法为创建模型方法，了解createState对了解了解页面整体结构至关重要的作用的。createState做了什么? createState在根据页面的组件布置情况创建对应的结构性的模型.并且模型的结构与页面的结构保持一致，这样非常方便了理解页面的整体情况，也非常变量的操作模型。

> 举例： 列表卡片节点

**描述**： 我们先简单说明下这个节点， 这个节点包含了2个部分， 一个是列表的部分，一个是卡片的部分，并给他们起名字， 列表模式，卡片模式， 显示列表模式时，不显示卡片模式，显示卡片模式时，不显示列表模式，功能为列表卡片来回切换，列表模式中， 包含一个查询区， 一个列表区， 卡片模式中， 包含一个表单区。

**`state`代码实现**：

```js
state = {
    showmode: 'list',  // showmode表示为当前的显示模式， 是列表模式，还是卡片模式， 他可以有两个值 list, card分表表示
    list: { // 列表模式的配置，包含查询区配置对象，表格区配置对象
        search: { // 查询区配置
            area: '',   //  查询区的区域编码, 你在模板中定义的编码是什么他就是什么
            onSearch: fn  //点击查询时候的处理函数
        },
        table: { // 表格区配置
            area: '', //    表格区的区域编码, 你在模板中定义的编码是什么他就是什么
            onSelect: fn // 点击选中时候的处理函数
        }
    },
    card: { // 卡片模式的配置，包含了表单区的配置对象
        form: { // 表单区
            area: '',  // 表单区的区域编码，你在模板中定义的编码是什么他就是什么
            onBeforeEdit: fn // 表单编辑前的处理函数
        }
    }
}
```

**`render`代码实现**：

​	render方法中，主要是渲染组件到页面， 我们根据什么来渲染页面，根据上面构建的state模型来渲染。

```js
render = () => {
    var renderList = () => { //渲染列表模式的是的页面，
    }
    var renderCard = () => { //渲染卡片模式的是的页面，
    }
}
```

​	我们应该怎么判断渲染的是列表还是卡片呢， 我们通过`state.showmode`来确定，根据`showmode`的当前值的状态来判断是调用 `renderList`还是`renderCard`，这样当我们重新设置模型的值(`setState`),就能够借助`React`的机制(见`react`的运作模式)，驱动视图变化了(`setState`会驱动调用`render`)所以我们可以这样写:

```js
render = () => {
    var renderList = () => { //渲染列表模式的是的页面，
    }
    var renderCard = () => { //渲染卡片模式的是的页面，
    }
    return this.state.showmode == 'list' ? renderList() : renderCard();
}
```

​	是不是非常简单,当我们要在列表和卡片模式中切换时， 我们只需要 `setState(showmode:'list'或者'card')`,就可以在列表和卡片间来回切换了， 非常便利，再也不用什么缓存了，而且切换时也不需要加载什么模板.非常快捷。那么`renderList`方法里面是怎么写的呢，也非常简单，我们再看一下`state`里面`list`的定义。我们就可以根据list里面的定义写`renderList`了，`state`结构和`render`结构保持了一致。

```js
list : { //列表模式的配置，包含查询区配置对象，表格区配置对象
    search: { //查询区配置
        area: '', // 查询区的区域编码, 你在模板中定义的编码是什么他就是什么
        onSearch: fn // 点击查询时候的处理函数
    },
    table: {// 表格区配置
        area: '', //    表格区的区域编码, 你在模板中定义的编码是什么他就是什么
        onSelect: fn // 点击选中时候的处理函数
    }
}
```

`renderList`方法内部写法例子：

```js
var renderList = () => { //渲染列表模式的是的页面，
    var { search, table } = this.state.list; //我们解构list里面的两个模型对象，就是search查询区的配置，table表格配置
    return <div>
        {this.props.search.NCCreateSearch(search.area, search)}
        {this.props.table.createSimpleTable(table.area, table)}
    </div>
}
```

现在我们看一下完整的例子代码,并进行一些总结:

```js
createState = () => {
    var state = {
        showmode: 'list', //  showmode表示为当前的显示模式， 是列表模式，还是卡片模式， 他可以有两个值 list, card分表表示
        list: {
            // 列表模式的配置，包含查询区配置对象，表格区配置对象
            search: {
                // 查询区配置
                area: '', //    查询区的区域编码, 你在模板中定义的编码是什么他就是什么
                onSearch: fn //  点击查询时候的处理函数
            },
            table: {// 表格区配置
                area: '',  //  表格区的区域编码, 你在模板中定义的编码是什么他就是什么
                onSelect: fn // 点击选中时候的处理函数
            }
        },
        card: { // 卡片模式的配置，包含了表单区的配置对象
            form: { //表单区
                area: '', //     表单区的区域编码，你在模板中定义的编码是什么他就是什么
                onBeforeEdit: fn //  表单编辑前的处理函数
            }
        }
    }
}
render = () => {
    var renderList = () => {
        var { search, table } = this.state.list; //我们解构list里面的两个模型对象，就是search查询区的配置，table表格配置
        return <div>
            {this.props.search.NCCreateSearch(search.area, search)}
            {this.props.table.createSimpleTable(table.area, table)}
        </div>
    }
    var renderCard = () => {
        var { form } = this.card; //我们解构card里面的两个模型对象，就是search查询区的配置，table表格配置
        return <div>
            {this.props.search.form(form.area, form)}
        </div>
    }
    return this.state.showmode == 'list' ? renderList() : renderCard();
}
```



## 3. 总结

​	代码`state`和`render`渲染的模型结构上是一致，这样我们能很快构建我们的页面，并非常容易修改，我们只需要修改我们的模型，就可以操控我们的页面了， 渲染只是在表现我们的模型。

