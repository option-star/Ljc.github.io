---
title: webkit技术内幕
date: 2021-11-13
sidebar: 'auto'
tags:
- 浏览器
categories:
- 浏览器
isShowComments: true
---



## 1 浏览器和浏览器内核

### 1.1 浏览器



### 1.2 浏览器内核及特性



### 1.3 WebKit内核

### 1.4 本书结构



## 2 HTML网页和结构

### 2.1 网页构成

### 2.2 网页结构

### 2.3 WebKit的网页渲染过程



## 3 WebKit架构和模块

### 3.1 Webkit架构及模块

### 3.2 基于Blink的Chromin浏览器结构

### 3.3 WebKit2

## 4 资源加载和网络调用栈

​	使用网络栈来下载网页和网页中的资源是渲染引擎工作过程的第一步,也是非常消耗时间的步骤。本章首先介绍网页的资源类型和 WebKit的资源加载机制，然后剖析Chromiun的多进程资源加载和缓存机制，以及高性能的网络技术。

### 4.1 WebKit资源加载机制

#### 4.1.1 资源

​	网络和资源加载是网页的加载和渲染过程中的第一步，也是必不可少的一步。网页本身就是一种资源，而且网页一般还需要依赖很多其他类型的资源，例如图片、视频等。因为资源的加载涉及网络和资源的缓存等机制，而且它们在整个渲染过程中占的比例并不少。本章将介绍 WebKit如何获取资源以及如何高效地管理资源。

HTML支持的资源主要包括一下类型：

-   **HTML**：HTML页面，包括格式各样的HTML元素。
-   **JavaScript**：JavaScript代码，可以内嵌在HTML文件中，也可以单独的文件存在。
-   **CSS样式表**：CSS样式资源，因为CSS代码除了可以内嵌在HTML文件之外，还可以以单独文件形式存在。
-   **图片**： 各种编码格式的图片资源，包括png、jep等。当然还有一些特殊的图片资源，例如SVG的2D矢量图形表示。
-   **SVG**： 用于绘制SVG中所需的2D矢量图形表示。
-   **CSS Shader** ：支持CSS Shader文件，目前WebKit支持该功能
-   **视频、音频和字幕**：多媒体资源及支持音视频的字幕文件（TextTrack）
-   **字体文件**： CSS支持自定义字体，CSS3引入的自定义字体文件。
-   **XSL样式表**： 使用XSLT语言编写的XSLT代码文件。

​	上面这些资源在 WebKit中均有不同的类来表示它们，它们的公共基类是CachedResource。图4-1中表示的是 CachedResource类和子类，基本上可以和上面的资源一一对应，其中有个地方笔者需要指出的就是——好像HTML文本没有对应的资源类，其实不然，在 WebKit中，它的类型叫 Main Resource类，与其对应的资源类型叫 Cached Raw Resource类。

![image-20211113112037211](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131120337.png)

​	读者可能会好奇为什么资源类的前面有“ Cached”字样,其实这是因为效率问题而引入的缓存机制，所有对资源的请求都会先获取缓存中的信息，以决定是否向服务器提出资源请求。

#### 4.1.2 资源缓存

​	资源的缓存机制是提高资源使用效率的有效方法。它的基本思想是建立一个资源的缓存池，当 WebKit需要请求资源的时候，先从资源池中查找是否存在相应的资源。如果有，WebKit则取出以便使用；如果没有，WebKit创建一个新的 CachedResource子类的对象，并发送真正的请求给服务器， WebKit收到资源后将其设置到该资源类的对象中去，以便于缓存后下次使用。这里的缓存指的是内存缓存，而不同于后面在网络栈部分的磁盘缓存。图4-2显示了这一机制的原理。

![image-20211113112632405](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131126454.png)

​	WebKit从资源池中査找资源的关键字是URL，因为标记资源唯一性的特征就是资源的URL。这也意味着，假如两个资源有不同的URL，但是它们的内容完全一样，也被认为是两个不同的资源。其实，上面是个简单的示意图,真实的过程比这里要复杂,这其中涉及到了资源的生命周期和失效机制。

#### 4.1.3 资源加载器

​	说到资源加载器，着实让人迷惑，它不像资源那么容易理解。按照加载器的类型来分，WebKit总共有三种类型的加载器。

​	第一种，针对每种资源类型的特定加载器，其特点是仅加载某一种资源。例如对于“ image”这个HIML元素，该元素需要图片资源，对应的特定资源加载器是Image Loader类。对于CSS自定义字体，它的特定资源加载器是 FronTloader类。这些资源加载器没有公共基类，其作用就是当需要请求资源时，由资源加载器负责加载并隐藏背后复杂的逻辑。加载器属于它的调用者，如图4-3所示的图片加载器。

![image-20211113113107846](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131131886.png)

​	第二种，资源缓存机制的资源加载器的特点是所有特定加载器都共享它来査找并插入缓存资源——CachedResourceloader类。特定加载器先是通过缓存机制的资源加载器来査找是否有缓存资源，它属于HTML的文档对象，如图4-4所示。

![image-20211113124231700](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131242831.png)

​	第三种，通用的资源加载器——Resourceloader类，是在 WebKit需要从网络或者文件系统获取资源的时候使用该类只负责获得资源的数据，因此被所有特定资源加载器所共享。它属于 CachedResource类，但它同CachedResourceLoader类没有继承关系(这点容易混淆),如图4-5所示。

![image-20211113124824226](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131248293.png)

​	之所以 WebKit这样设计加载器，主要还是因为 WebKit想将其中的复杂机制逐渐简化为若干简单步骤。但是，这一设计确实很复杂难懂，希望以后能够更加清晰化。

#### 4.1.4 过程

​	经过上面这些分析，相信读者对资源加载过程已经有一个大致的印象了。图4-6描述的是一个带有资源缓存机制的资源加载的全过程，包括资源已经在缓存中和不在缓存中两种情况。

​	为了便于说明这一过程，下面结合一个实际例子加以说明资源是如何被加载的(也就是整个调用过程)。假设现有一个“img”元素，其属性“src”的值是一个有效的URL地址,那么当HTML解析器解析到该元素的该属性时，WebKit会创建个ImageLoader对象来加载该资源， ImageLoader对象通过图4-6所示的过程创建一个加载资源的请求。下面笔者将所涉及的类都包含进来，大致的调用顺序也是从上到下。具体到最下面的 ResourceHandleInternal类，它依赖于每个 WebKit移植的实现策略。 Chromiun采用了多进程资源加载策略，这将在下面一节介绍。

​	鉴于从网络获取资源是一个非常耗时的过程，通常一些资源的加载是异步执行的，也就是说资源的获取和加载不会阻碍当前 WebKit的渲染过程，例如图片、CS文件。当然，网页也存在某些特别的资源会阻碍主线程的渲染过程，例如 JavaScript代码文件。这会严重影响 WebKit下载资源的效率，因为后面可能还有许多需要下载的资源，WebKit怎么做呢?

![image-20211113125343610](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131302266.png)

​	因为主线程被阻碍了，后面的解析工作没有办法继续往下进行，所以对于HTML网页中后面使用的资源也没有办法知道并发送下载请求。当遇到这种情况的时候，WebKit的做法是这样的：当前的主线程被阻碍时， WebKit会启动另外一个线程去遍历后面的HTML网页，收集需要的资源URL，然后发送请求，这样就可以避免被阻碍。与此同时，WebKit能够并发下载这些资源，甚至并发下载 JavaScript代码资源。这种机制对于网页的加载提速很是明显。

#### 4.1.5 资源的生命周期

​	同 CachedResourceLoader对象一样，资源池也属于HTML文档对象。关于HTML文档，前面笔者在介绍网页框结构的时候提到过。

​	问题来了，资源池中的资源生命周期是什么呢？资源池不能无限大，必须要用相应的机制来替换其中的资源，从而加入新的资源。资源池使用的机制其实很简单，就是采用[LRU算法](https://baike.baidu.com/item/LRU/1269842?fr=aladdin)。

​	另一方面，当一个资源加载后，通常它会被放入资源池，以便之后使用。问题是，WebKit如何判断下次使用的时候是否需要更新该资源从而对服务器重新请求呢？因为服务器可能在某段时间之后更新了该资源。

​	考虑这样的场景，当用户打开网页后，他想刷新当前的页面。这种情况下，资源池会出现怎样的情况呢？是清除所有的资源，重新获得呢？还是直接利用当前的资源？都不是。对于某些资源，WebKit需要直接重新发送请求，要求服务器端将内容重新发送过来。但对于很多资源，WebKit则可以利用HTTP协议减少网络负载。在HTTP协议的规范中对此有规定，浏览器可以发送消息确认是否需要更新，如果有，浏览器则重新获取该资源：否则就需要利用该资源。

​	Webkit的做法是，首先判断资源是否在资源池中，如果是，那么发送一个HTTP请求给服务器，说明该资源在本地的一些信息，例如该资源什么时间修改的，服务器则根据该信息作判断，如果没有更新，服务器则发送回状态码304，表明无需更新，那么直接利用资源池中原来的资源；否则，WebKit申请下载最新的资源内容。

#### 4.1.6 实践：资源的缓存

​	下面笔者以实际的例子来说明资源的缓存机制。因为 Chrom浏览器的开发者工具可以设置打开或者关闭该机制，所以，读者可以很方便地理解资源的缓存机制，具体步骤如下。

1. 依旧打开Chome浏览器和它的开发者工具。然后在地址栏中输入www.baidu.com并点击开发者工具的“network”按钮。
2. 打开开发者工具的“设置”按钮，在“General”标签页中的“Disable Cache”前大钩，然后关掉设置界面。
3. 重新刷新页面（F5），得到图4-7所示的结果。特别要关注的是资源“bdlogo.gif”，单击它可看到该资源的HTTP请求和HTTP返回结果。从图中读者看到，“bdlogo.gif”成功地被浏览器重新从网络申请到了资源。

![image-20211113133615644](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131336730.png)

4. 打开开发者工具的“设置”按钮，在“ General”页中把“ Disable Cache”前的钩去掉，然后关掉设置界面。
5. 重新刷新页面，就会得到如图4-8所示的结果。继续关注资源“ balog.gif”，读者会发现它的状态码变成304，表明资源没有发生改变，可直接利用资源
    池中的资源。是什么带来第3步和第5步中的差别呢？原因在于打开或者关闭“cache”机制。在这两种不同的条件下，WebKit会发送不同的HTTP头来请求资源。图4-9告诉读者这发生的一切。图中左边表示的是第3步中的资源请求HTTP头，而图中右边表示的则是第5步中的资源请求HTTP头，注意其中加粗的部分。

![image-20211113133719329](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131337403.png)

![image-20211113133910458](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131339532.png)

​	那么，当用户单击“关闭缓存”按钮的时候，WebKit背后在做什么呢？图4-10解释了内部的工作方式。最上面的是 Chrom的开发者工具( Dev Tools)直接清除掉MemoryCache对象中的所有资源，Memory Cache对象是全局唯一的。在清除掉该对象中的资源之后，WebKit立刻就会重新打开缓存机制。所以，经过上面的第三步之后 WebKit会打开缓存机制。这是因为在执行第三步的时候，WebKit会先清除掉资源池中的资源，而本身第三步的资源则会保存在资源池中，并立刻生效。所以之后执行第五步时，WebKit立刻就可以使用第三步缓存的资源。

![image-20211113134327216](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111131343278.png)

### 1.2 Chromium多进程资源加载 74



### 1.3 网络栈 78



## 2 HTML解析器和DOM模型 101

### 2.1 DOM模型 101

### 2.2 HTML解释器 107



### 2.3 DOM的事件机制 121 



### 2.4 影子（Shadow）DOM 127



## 3 CSS解析器和样式布局 131 

### 3.1 CSS基本功能 131



### 3.2 CSS解析器和规则匹配 143



### 3.3 WebKit布局 152

 

## 4 渲染基础157

### 4.1 RenderObject树 157



### 4.2 网页层次和RenderLayer树 163



### 4.3 渲染方式 167



### 4.4 WebKit软件渲染技术 172



## 5 硬件加速机制 183

### 5.1 硬件加速基础 183



### 5.2 Chromium的硬件加速机制194

### 5.3 其他硬件加速模块 216

## 6 JavaScript引擎 231

### 6.1 概述 231



### 6.2 V8引擎 242



### 6.3 JavaScriptCore引擎 259



## 7 安全机制 353

### 7.1 网页安全模型 353

### 7.2 沙箱模型 366

