---
title: 内存泄露
date: 2021-11-07
sidebar: 'auto'
tags:
- 浏览器
categories:
- 浏览器垃圾回收机制
isShowComments: true
---



::: tip

**内存泄露**：系统进程不再使用的内存，没有及时释放，就叫做内存泄露

:::

## JS内存泄露

### 1. 意外的全局变量

#### 原因

由于js对于未什么的变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是window对象。变量只有在窗口关闭或者重新刷新页面时才会被释放，如果未声明的变量缓存着大量的数据，就会导致内存泄露。

#### 举例

-   未声明的变量

```js
function fn() {
  a = 'global variable'
}
fn()
```

-   使用this创建的变量（this指向window）

```js
function fn() {
  this.a = 'global variable'
}
fn()
```

#### 解决

1.   避免创建全局变量
2.   使用严格模式`use strict`

### 2. 闭包

#### 原因

闭包可以读取到函数内部的变量，那些变量都保存在内存中。如果在使用结束之后没有将局部变量清除，就可能导致内存泄露

#### 实例

```JS
function fn () {
  var a = "I'm a";
  return function () {
    console.log(a);
  };
}
```

#### 解决

- 将事件处理函数定义在外部，解除闭包

### 3. 没清理的DOM引用

#### 原因

获取一个DOM元素的引用，而后面这个元素被删除，由于一直保留这个元素的引用，所以它也无法被回收。

#### 实例

```js
// 在对象中引用DOM
var elements = {
  btn: document.getElementById('btn'),
}
function doSomeThing() {
  elements.btn.click()
}

function removeBtn() {
  // 将body中的btn移除, 也就是移除 DOM树中的btn
  document.body.removeChild(document.getElementById('button'))
  // 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被GC回收
}
```

#### 解决

- 手动删除, `elements.btn = null`

### 4. 被遗忘的定时器或者回调函数

#### 原因

设置了`setInterval`定时器，而忘记取消它，如果循环函数有对外部变量的引用，那么这个变量会被一直保留在内存中，而无法被回收。

#### 实例

```js
// 定时器
var serverData = loadData()
setInterval(function () {
  var renderer = document.getElementById('renderer')
  if (renderer) {
    renderer.innerHTML = JSON.stringify(serverData)
  }
}, 5000)

// 观察者模式
var btn = document.getElementById('btn')
function onClick(element) {
  element.innerHTMl = "I'm innerHTML"
}
btn.addEventListener('click', onClick)
```

#### 解决

- 手动删除定时器

## ES6防止内存泄露

### 原因

weakset和weakmap，这两种数据结构，如果其他对象不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。

### 举例

```js
const wm = new WeakMap()
const element = document.getElementById('example')
vm.set(element, 'something')
vm.get(element)
```

事件监听

```js
// 代码1
ele.addEventListener('click', handler, false)

// 代码2
const listener = new WeakMap()
listener.set(ele, handler)
ele.addEventListener('click', listener.get(ele), false)
```

代码2比起代码1的好处是：由于监听函数是放在Weakmap里面，一旦dom对象消失，与它绑定的监听函数handler也会自动消失。

## Vue常见内存泄露情况



### 1. 全局变量

#### 原因

声明的全局变量在切换页面的时候没有清空

#### 实例

```js
<template>
  <div id="home">这里是首页</div>
</template>

<script>
  export default {
    mounted() {
      window.test = {
        // 此处在全局window对象中引用了本页面的dom对象
        name: 'home',
        node: document.getElementById('home'),
      }
    },
  }
</script>
```

#### 解决

在页面销毁的时候顺便处理掉引用

```js
destroyed () {
  window.test = null // 页面卸载的时候解除引用
 }
```



### 2. 监听window/body等事件没有解绑

#### 实例

```js
<template>
<div id="home">这里是首页</div>
</template>

<script>
export default {
mounted () {
  window.addEventListener('resize', this.func) // window对象引用了home页面的方法
}
}
</script>
```

#### 解决

在页面销毁时，解除引用，释放内存

```js
beforeDestroy () {
  window.removeEventListener('resize', this.func)
}
```

### 3. 绑在[EventBus](https://juejin.cn/post/6844903895798382599)的事件没有解绑

#### 实例

```js
<template>
  <div id="home">这里是首页</div>
</template>

<script>
export default {
  mounted () {
   this.$EventBus.$on('homeTask', res => this.func(res))
  }
}
</script>
```

#### 解决

页面销毁时解除引用

```js
destroyed () {
 this.$EventBus.$off()
}
```

### 4. Echarts

#### 原因

每一个图例在没有数据的时候，都会创建一个定时器去渲染气泡，在页面切换的时候，虽然图例销毁了，但echart的实例还存在内存中，所以其定时器也没有被销毁，这就会导致Echats占比CPU高，导致页面卡顿

#### 解决

页面销毁前，释放该页面的chart资源

```js
beforeDestroy () {
  this.chart.clear()
}
```



