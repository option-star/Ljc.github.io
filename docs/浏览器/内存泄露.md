---
title: 内存泄露
date: 2021-11-07
sidebar: 'auto'
tags:
- 浏览器
categories:
- 浏览器垃圾回收机制
isShowComments: true
---



::: tip

**内存泄露**：系统进程不再使用的内存，没有及时释放，就叫做内存泄露

:::

## JS内存泄露

### 1. 意外的全局变量

#### 原因

由于js对于未什么的变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是window对象。变量只有在窗口关闭或者重新刷新页面时才会被释放，如果未声明的变量缓存着大量的数据，就会导致内存泄露。

#### 举例

-   未声明的变量

```js
function fn() {
  a = 'global variable'
}
fn()
```

-   使用this创建的变量（this指向window）

```js
function fn() {
  this.a = 'global variable'
}
fn()
```

#### 解决

1.   避免创建全局变量
2.   使用严格模式`use strict`

### 2. 闭包

#### 原因

闭包可以读取到函数内部的变量，那些变量都保存在内存中。如果在使用结束之后没有将局部变量清除，就可能导致内存泄露

#### 实例

```JS
function fn () {
  var a = "I'm a";
  return function () {
    console.log(a);
  };
}
```

#### 解决

- 将事件处理函数定义在外部，解除闭包

### 3. 没清理的DOM引用

#### 原因

获取一个DOM元素的引用，而后面这个元素被删除，由于一直保留这个元素的引用，所以它也无法被回收。

#### 实例

```js
// 在对象中引用DOM
var elements = {
  btn: document.getElementById('btn'),
}
function doSomeThing() {
  elements.btn.click()
}

function removeBtn() {
  // 将body中的btn移除, 也就是移除 DOM树中的btn
  document.body.removeChild(document.getElementById('button'))
  // 但是此时全局变量elements还是保留了对btn的引用, btn还是存在于内存中,不能被GC回收
}
```

#### 解决

- 手动删除, `elements.btn = null`

### 4. 被遗忘的定时器或者回调函数

#### 原因

设置了`setInterval`定时器，而忘记取消它，如果循环函数有对外部变量的引用，那么这个变量会被一直保留在内存中，而无法被回收。

#### 实例

```js
// 定时器
var serverData = loadData()
setInterval(function () {
  var renderer = document.getElementById('renderer')
  if (renderer) {
    renderer.innerHTML = JSON.stringify(serverData)
  }
}, 5000)

// 观察者模式
var btn = document.getElementById('btn')
function onClick(element) {
  element.innerHTMl = "I'm innerHTML"
}
btn.addEventListener('click', onClick)
```

#### 解决

- 手动删除定时器

## ES6防止内存泄露



## Vue常见内存泄露情况





