---
title: 垃圾回收
date: 2021-11-07
sidebar: 'auto'
tags:
- 垃圾回收
categories:
- 浏览器
isShowComments: true
---

## GC是什么

GC（Garbage Collection）， 程序工作过程中会产生很多垃圾，这些垃圾是程序中不用的内存空间或者是之前用过的，以后不会再用的内存空间

## 垃圾回收策略

### 标记清除法

::: tip

**标记清除法**：引擎在执行GC时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，这些出发点称之为一组根对象，而根对象在浏览器中有全局的window对象、文档D0M树等

:::

#### 过程

1. 垃圾收集器在运行时，会给内存中的变量全部标记成0
2. 然后从根对象开始遍历，遍历到的对象标记为1
3. 清除所有标记为0的垃圾，销毁并回收它们所占用的内存空间
4. 最后，把所有对象的标记修改为0，等待下一轮的垃圾回收

#### 优点

- 实现简单，只需用一位二进制标记状态（0/1）

#### 缺点

1. **内存碎片化**。清除后剩余对象内存位置不变会导致空闲空间不连续，出现内存碎片化。
2. **分配速度慢**。即时使用First-fit策略，操作时间复杂度依旧为O(n)

#### 内存分配

![image-20211107091459458](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070914644.png)

清除后剩余对象位置不变而导致空闲内存不连续，也就出现“内存碎片”，这就涉及了“内存分配问题”。

![image-20211107091631820](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070916935.png)

假设新建对象分配内存需要大小为size,由于空闲内存不连续，则需要对空闲内存列表进行一次单向遍历找出大于等于size的块才能为其分配。有一下三种分配方式。

1. **First-fit**, 找到大于等于size的块立即返回
2. **Best-fit**,  返回大于等于size的最小分块
3. **Worst-fit**, 找到最大分块，然后切成两部分，一部分size大小，并将该部分返回。

这三种策略里面Worst-fit的空间利用率看起来最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于First-fit和Best-fit来说，考虑到分配的速度和效率First-fit是更为明智的选择。

#### 优化

::: tip

**标记清除法** ： 标记阶段与标记清除法一致，只是标记结束后，标记整理算法会将不需清理的对象向内存的一端移动，最后清理标记的内存。

:::

![image-20211107092141007](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070921181.png)



### 引用计数法

![截屏2021-08-12 下午10.23.45.png](https://gitee.com/ljcdzh/my_pic/raw/master/img/202111070939688.webp)





## V8对GC的优化





## 参考

1. [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-0)

